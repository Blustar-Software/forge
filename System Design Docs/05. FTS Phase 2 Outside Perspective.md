## FTS Phase 2: Outside Perspective (Forge)

This note is a candid, third-party-style view of Forge and FTS, intended to help when switching contexts across machines.

### One-Paragraph Summary
Forge already feels like a disciplined training system: deterministic checks, staged progression, and a clear curriculum. The main gap between “Phase 1 complete” and “Phase 2 ready” is execution control + feedback depth. You have constraint profiles and telemetry stubs, but you still need a tighter execution harness and more diagnostic feedback to deliver the full FTS promise. The adaptive engine is started, but it needs scaffolding loops to feel like coaching instead of grading.

---

## What’s Strong Right Now
- **Cohesive training flow:** staged gating, repeatable units, clear objectives.
- **Curriculum depth and pacing:** careful progression, bridge challenges, projects.
- **Constraint scaffolding exists:** topic profiles + per-challenge overrides.
- **Deterministic checks are the default:** output matching is reliable; fixtures help.
- **Telemetry foundation:** performance log + adaptive stats exist.

## What Still Feels “Phase 1”
- **Execution control is heuristic:** token checks are helpful but not hard sandboxing.
- **Feedback is shallow outside special cases:** failure tells “what,” not “why.”
- **Adaptive engine is limited:** it weights selection but doesn’t enforce mastery loops.
- **Manual-check determinism gaps:** still relies on user environment for some units.

---

## The Minimum “Phase 2-Grade” Upgrade Set
These are the smallest changes that would make Forge feel distinctly Phase‑2:

1. **Controlled Execution Harness (FTS‑2)**
   - Enforce allowed APIs/imports with stronger preflight checks.
   - Lock down file IO / network / concurrency per challenge (not just advisory).
   - Run challenges in a constrained mode (even if still heuristic, must be enforceable).

2. **Feedback Engine v1 (FTS‑5)**
   - Consistent line‑by‑line diffs in all modes (main, gate, random, verify).
   - Per‑challenge diagnostic messages for common mistakes (top 2–3 patterns).
   - Clear “what failed” and “why it failed” surfaced in CLI output.

3. **Adaptive Mastery Loop (FTS‑8/9)**
   - Adaptive on by default, opt‑out flag retained.
   - Add “retry sets” with scaffolding (simpler variants or relaxed constraints).
   - Gate progression on stability (N consecutive passes in weak topics).

4. **Constraint Mastery Ladder (FTS‑9)**
   - Constraints escalate: warn → block → relax after clean passes.
   - Constraint enforcement tied to learner stability, not just challenge metadata.

5. **Debrief + Report (FTS‑15)**
   - Stage debrief summary: pass rate, weak topics, time per stage.
   - `forge report` that explains performance trends and next steps.

6. **Solution Integrity**
   - Keep solutions available, but confirm pre‑pass access and log as assisted.
   - Pre‑pass solution view queues a short practice set after completion (resume if interrupted).
   - Post‑pass solution view is penalty‑free.
   - Assisted passes should not count toward mastery stability.

---

## Suggested Phase 2 Milestones (Pragmatic)
### Phase 2.1 — Execution Control
- Harden constraint enforcement and unify across all flows.
- Improve token checks for API blocks (file/network/concurrency).
- If no sandbox yet, simulate it via stricter gates + fatal enforcement.

### Phase 2.2 — Feedback + Adaptive
- Line‑diff feedback everywhere; common‑mistake prompts by topic.
- Adaptive on by default; retry sets + stability gating.

### Phase 2.3 — Mastery + Reporting
- Constraint ladder (warn/block/relax).
- Stage debriefs + `forge report`.
- Add audit tooling (sequencing/fixtures/constraint coverage checks).

---

## Outside View: What Would Make It Feel “Great”
- **Sharper diagnosis:** learners should know exactly why a solution failed.
- **Visible coaching:** adaptive should feel like guided practice, not randomization.
- **Harder constraints:** if a rule is in the prompt, it should be enforced.
- **Short debrief loop:** end‑of‑stage summaries with clear next steps.

---

## Risks to Watch
- **False positives in heuristic constraints:** avoid punishing learners for syntax noise.
- **Feedback overload:** keep diagnostics short and action‑oriented.
- **Adaptive fatigue:** keep retry sets short and purposeful.
- **Regression of determinism:** avoid introducing nondeterminism as adaptive expands.

---

## If You Need to Pick One High-Leverage Move
Implement the feedback engine v1 first. It improves the learning experience immediately,
builds trust in the checks, and pairs well with the constraint system you already have.
