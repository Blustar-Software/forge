# Crust Curriculum Map (Planned)

This document defines the planned Crust layer. Crust is advanced/professional Swift and follows the same 3-pass structure and project gating as Core and Mantle.

Notes
- Crust is not yet implemented in the CLI.
- Numbering is proposed and can shift once authoring starts.
- Tier/layer tags should follow existing conventions: tier `mainline`/`extra`, layer `crust`.

## Structure Overview (Proposed)
- Crust 1: 172–189 (18 challenges)
- Crust 2: 190–207 (18 challenges)
- Crust 3: 208–225 (18 challenges)
- Crust extras (optional): 226+ (practice and variety)

## Sequencing Principles
- Introduce concurrency and actors early (Crust 1) to set the mental model.
- Keep "how to use" macros and SwiftPM before "how to create" macros.
- Defer unsafe/interoperability to Crust 3 after core language mastery.
- Reinforce performance concepts in Crust 2 (CoW, profiling, memory layout).

## Crust 1 (First Pass — Advanced Foundations)
Focus: concurrency, isolation, property wrappers, and key paths.

Proposed challenge map:
- 172. async/await Basics (async function, await call)
- 173. Task Basics (spawn, await result)
- 174. Structured Concurrency (task groups intro)
- 175. Async Sequences (for await)
- 176. Cancellation (Task.isCancelled)
- 177. Actor Basics (isolated state)
- 178. MainActor + UI-style boundary (simulation)
- 179. Sendable Overview (value safety)
- 180. Property Wrapper Usage (built-in wrapper)
- 181. Custom Property Wrapper (basic)
- 182. Projected Values (wrappedValue, projectedValue)
- 183. Key Path Syntax (\\Type.property)
- 184. Key Path Sorting/Mapping
- 185. Lazy Collections (lazy + map/filter)
- 186. Custom Sequence Basics
- 187. Custom Iterator
- 188. Sequence vs Collection (semantics)
- 189. Integration Challenge (async + actor + wrapper)

## Crust 2 (Second Pass — Advanced Language & Performance)
Focus: advanced generics, language features, performance, SwiftPM, macros (use).

Proposed challenge map:
- 190. Opaque Types (some)
- 191. Existentials vs Generics (any)
- 192. Type Erasure (basic wrapper)
- 193. Primary Associated Types (PATs)
- 194. where Clauses (advanced constraints)
- 195. Copy-on-Write (behavioral check)
- 196. Memory Layout (MemoryLayout basics)
- 197. Profiling Mindset (micro benchmark stub)
- 198. Custom Operators
- 199. Custom Subscripts
- 200. dynamicMemberLookup
- 201. dynamicCallable
- 202. Result Builders (use)
- 203. Macros (use and inspect expansion)
- 204. SwiftPM Basics (package + target types)
- 205. Dependencies + Module Imports
- 206. Build Configs + Flags (debug/release)
- 207. Integration Challenge (package + feature)

## Crust 3 (Third Pass — Mastery & Professional Practice)
Focus: advanced tooling, architecture, testing, unsafe/interop.

Proposed challenge map:
- 208. Macro Authoring (concepts)
- 209. Reflection + Metadata (Mirror basics)
- 210. Witness Tables (conceptual drill)
- 211. MVVM/MVC (structure exercise)
- 212. Dependency Injection (constructor, protocol)
- 213. Coordinators (navigation abstraction)
- 214. Repositories (data access boundary)
- 215. Protocol Mocking (manual stub)
- 216. TDD Cycle (red/green/refactor drill)
- 217. Async Testing (XCTest async)
- 218. UI Testing Concepts (simulation)
- 219. Unsafe Pointers (basic safety rules)
- 220. C Interop (import see also)
- 221. Objective-C Interop (bridging)
- 222. LLDB Tactics (breakpoints, po)
- 223. Diagnostics + Error Surfacing
- 224. Git Workflows (branching, PRs)
- 225. Integration Challenge (professional tool)

## Projects (Crust)
Crust projects should be substantive, self-directed, and closer to production patterns.

Mainline projects:
- crust1a: Async Client (concurrency + actors + wrappers)
- crust2a: Config DSL (result builders + SwiftPM module)
- crust3a: Mini Framework (macros + DI + testing)

Extra projects (optional):
- crust1b: KeyPath Data Transformer
- crust1c: Async Task Orchestrator
- crust2b: Perf Profiled Collection
- crust2c: Feature Flag Package
- crust3b: Modular CLI Tool
- crust3c: Macro-Backed DSL

## Notes for Implementation
- Many Crust challenges will be manual-check or "run the sample" style. Mark them clearly.
- Keep I/O scaffolding minimal; focus on correctness and reasoning.
- Avoid relying on OS features that are not available in the sandbox.
