[
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Inspect and transform strings",
    "expectedOutput": "11\nforge ready\ntrue",
    "fixtureFiles": [],
    "hints": [
      "Strings have properties and methods for basic inspection.",
      "Use phrase.count and phrase.lowercased().",
      "Use phrase.contains(\"Ready\") to check for a substring."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: String Inspection\nString inspection helps you validate and analyze text.\n\nOverview:\n- Use helpers like count, contains, and prefix/suffix checks.\n- Transform case to normalize comparisons.\n\nLength and case:\n    let label = \"Forge\"\n    print(label.count)\n    print(label.lowercased())\n\nSearch and matching:\n- contains(\"text\") to search\n- hasPrefix(\"pre\") / hasSuffix(\"suf\")\n    let log = \"heat:1500\"\n    print(log.hasPrefix(\"heat:\"))",
    "manualCheck": false,
    "number": 43,
    "requires": [],
    "solution": "print(phrase.count)\nprint(phrase.lowercased())\nprint(phrase.contains(\"Ready\"))",
    "starterCode": "// Challenge 43: String Methods\n// Use basic string properties and methods.\n\nlet phrase = \"Forge Ready\"\n\n// TODO: Print the length of the phrase\n// TODO: Print the lowercase version of the phrase\n// TODO: Print whether the phrase contains \"Ready\"",
    "tier": "mainline",
    "title": "String Methods",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Dictionaries\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Loop through key-value pairs",
    "expectedOutput": "2\n4",
    "fixtureFiles": [],
    "hints": [
      "Loop through the dictionary with for (metal, count) in inventory.",
      "Use Int variables to track totals as you iterate."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Collection Iteration\nIterate arrays and dictionaries to summarize data.\n\nArrays:\n    for value in temps {\n        print(value)\n    }\n\nDictionaries:\n    for (key, value) in readings {\n        print(\"\\(key): \\(value)\")\n    }\n\nStable order:\n- Dictionary order is not guaranteed.\n- Use dict.keys.sorted() for stable output when needed.",
    "manualCheck": false,
    "number": 44,
    "requires": [],
    "solution": "var total = 0\nvar metalCount = 0\n\nfor (_, count) in inventory {\n    total += count\n    metalCount += 1\n}\n\nprint(metalCount)\nprint(total)",
    "starterCode": "// Challenge 44: Dictionary Iteration\n// Summarize the inventory totals.\n\nlet inventory = [\"Iron\": 3, \"Gold\": 1]\n\n// TODO: Loop over each (metal, count) pair\n// TODO: Sum the total ingot count\n// TODO: Count how many metals are in the inventory\n// TODO: Print the metal count, then the total ingots",
    "tier": "mainline",
    "title": "Dictionary Iteration",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Dictionaries\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Print dictionary items in a stable order",
    "expectedOutput": "Gold: 1\nIron: 3",
    "fixtureFiles": [],
    "hints": [
      "Dictionaries can provide their keys as a collection.",
      "Use inventory.keys.sorted() for a stable order.",
      "Read values through the subscript (inventory[key])."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Collection Iteration\nIterate arrays and dictionaries to summarize data.\n\nArrays:\n    for value in temps {\n        print(value)\n    }\n\nDictionaries:\n    for (key, value) in readings {\n        print(\"\\(key): \\(value)\")\n    }\n\nStable order:\n- Dictionary order is not guaranteed.\n- Use dict.keys.sorted() for stable output when needed.",
    "manualCheck": false,
    "number": 45,
    "requires": [],
    "solution": "for key in inventory.keys.sorted() {\n    if let count = inventory[key] {\n        print(\"\\(key): \\(count)\")\n    }\n}",
    "starterCode": "// Challenge 45: Dictionary Ordering\n// Print inventory items in a stable order.\n\nlet inventory = [\"Iron\": 3, \"Gold\": 1]\n\n// TODO: Loop over keys in alphabetical order\n// TODO: Print \"<metal>: <count>\" for each item",
    "tier": "mainline",
    "title": "Dictionary Ordering",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Check string prefixes and suffixes",
    "expectedOutput": "true\ntrue",
    "fixtureFiles": [],
    "hints": [
      "hasPrefix and hasSuffix return Bool values."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: String Inspection\nString inspection helps you validate and analyze text.\n\nOverview:\n- Use helpers like count, contains, and prefix/suffix checks.\n- Transform case to normalize comparisons.\n\nLength and case:\n    let label = \"Forge\"\n    print(label.count)\n    print(label.lowercased())\n\nSearch and matching:\n- contains(\"text\") to search\n- hasPrefix(\"pre\") / hasSuffix(\"suf\")\n    let log = \"heat:1500\"\n    print(log.hasPrefix(\"heat:\"))",
    "manualCheck": false,
    "number": 46,
    "requires": [],
    "solution": "print(code.hasPrefix(\"Forge\"))\nprint(code.hasSuffix(\"01\"))",
    "starterCode": "// Challenge 46: String Prefix & Suffix\n// Check the start and end of a string.\n\nlet code = \"Forge-01\"\n\n// TODO: Print whether 'code' has prefix \"Forge\"\n// TODO: Print whether 'code' has suffix \"01\"",
    "tier": "mainline",
    "title": "String Prefix & Suffix",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(label param: Type) -> ReturnType { ... }\n- External vs internal labels: func f(external internal: Type)\n- Omit labels with _: func f(_ value: Type)\n- Default values: param: Type = value\n- Variadics: param: Type...\n- inout params mutate caller; call with &value\n- Nested functions are allowed inside functions\n- Tuple return types: -> (min: Int, max: Int)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Design clear APIs with distinct labels",
    "expectedOutput": "Heat: 1500",
    "fixtureFiles": [],
    "hints": [
      "External and internal labels can differ in a function signature.",
      "External labels appear at call sites."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions (Advanced)\nAdvanced features make functions more expressive.\n\nLabels:\n- External/internal: func heat(at value: Int)\n- Omit labels with _: func log(_ value: String)\n\nDefault values:\n    func heatBoost(_ base: Int, intensity: Int = 1) -> Int {\n        return base + (intensity * 100)\n    }\n\nVariadics:\n    func average(_ values: Int...) -> Int {\n        return values.reduce(0, +) / values.count\n    }\n\ninout parameters:\n- Mutate caller values with `&`.\n    func clamp(_ value: inout Int, max: Int) {\n        if value > max { value = max }\n    }\n\nNested helpers:\n- Define small helper functions inside a larger function for clarity.",
    "manualCheck": false,
    "number": 47,
    "requires": [],
    "solution": "func forgeHeat(at temperature: Int) {\n    print(\"Heat: \\(temperature)\")\n}\n\nforgeHeat(at: 1500)",
    "starterCode": "// Challenge 47: External & Internal Labels\n// Create a function with different external and internal labels.\n\n// TODO: Create a function called 'forgeHeat' that uses:\n// external label: at\n// internal label: temperature\n// It should print \"Heat: <temperature>\"\n\n// TODO: Call the function with 1500",
    "tier": "mainline",
    "title": "External & Internal Labels",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(label param: Type) -> ReturnType { ... }\n- External vs internal labels: func f(external internal: Type)\n- Omit labels with _: func f(_ value: Type)\n- Default values: param: Type = value\n- Variadics: param: Type...\n- inout params mutate caller; call with &value\n- Nested functions are allowed inside functions\n- Tuple return types: -> (min: Int, max: Int)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Omit external labels when needed",
    "expectedOutput": "Metal: Iron",
    "fixtureFiles": [],
    "hints": [
      "Use an underscore in the signature: announce(_ metal: String).",
      "When underscore is used, call the function without an external label."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions (Advanced)\nAdvanced features make functions more expressive.\n\nLabels:\n- External/internal: func heat(at value: Int)\n- Omit labels with _: func log(_ value: String)\n\nDefault values:\n    func heatBoost(_ base: Int, intensity: Int = 1) -> Int {\n        return base + (intensity * 100)\n    }\n\nVariadics:\n    func average(_ values: Int...) -> Int {\n        return values.reduce(0, +) / values.count\n    }\n\ninout parameters:\n- Mutate caller values with `&`.\n    func clamp(_ value: inout Int, max: Int) {\n        if value > max { value = max }\n    }\n\nNested helpers:\n- Define small helper functions inside a larger function for clarity.",
    "manualCheck": false,
    "number": 48,
    "requires": [],
    "solution": "func announce(_ metal: String) {\n    print(\"Metal: \\(metal)\")\n}\n\nannounce(\"Iron\")",
    "starterCode": "// Challenge 48: Void Argument Labels\n// Use _ to omit the external label.\n\n// TODO: Create a function 'announce' that omits the external label\n// and prints \"Metal: <metal>\"\n\n// TODO: Call announce with \"Iron\" (no label)",
    "tier": "mainline",
    "title": "Void Argument Labels",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(label param: Type) -> ReturnType { ... }\n- External vs internal labels: func f(external internal: Type)\n- Omit labels with _: func f(_ value: Type)\n- Default values: param: Type = value\n- Variadics: param: Type...\n- inout params mutate caller; call with &value\n- Nested functions are allowed inside functions\n- Tuple return types: -> (min: Int, max: Int)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use default values to simplify calls",
    "expectedOutput": "Striking Iron with intensity 1\nStriking Gold with intensity 3",
    "fixtureFiles": [],
    "hints": [
      "Default parameter values make arguments optional.",
      "Signature example: strike(_ metal: String, intensity: Int = 1).",
      "Default parameters can be omitted at the call site."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions (Advanced)\nAdvanced features make functions more expressive.\n\nLabels:\n- External/internal: func heat(at value: Int)\n- Omit labels with _: func log(_ value: String)\n\nDefault values:\n    func heatBoost(_ base: Int, intensity: Int = 1) -> Int {\n        return base + (intensity * 100)\n    }\n\nVariadics:\n    func average(_ values: Int...) -> Int {\n        return values.reduce(0, +) / values.count\n    }\n\ninout parameters:\n- Mutate caller values with `&`.\n    func clamp(_ value: inout Int, max: Int) {\n        if value > max { value = max }\n    }\n\nNested helpers:\n- Define small helper functions inside a larger function for clarity.",
    "manualCheck": false,
    "number": 49,
    "requires": [],
    "solution": "func strike(_ metal: String, intensity: Int = 1) {\n    print(\"Striking \\(metal) with intensity \\(intensity)\")\n}\n\nstrike(\"Iron\")\nstrike(\"Gold\", intensity: 3)",
    "starterCode": "// Challenge 49: Default Parameters\n// Add a default intensity parameter.\n\n// TODO: Create a function 'strike' that takes:\n// - a metal\n// - an intensity with a default value of 1\n// Print \"Striking <metal> with intensity <intensity>\"\n\n// TODO: Call strike with \"Iron\"\n// TODO: Call strike with \"Gold\" and intensity 3",
    "tier": "mainline",
    "title": "Default Parameters",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(label param: Type) -> ReturnType { ... }\n- External vs internal labels: func f(external internal: Type)\n- Omit labels with _: func f(_ value: Type)\n- Default values: param: Type = value\n- Variadics: param: Type...\n- inout params mutate caller; call with &value\n- Nested functions are allowed inside functions\n- Tuple return types: -> (min: Int, max: Int)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Accept any number of values",
    "expectedOutput": "1200",
    "fixtureFiles": [],
    "hints": [
      "Variadic parameters accept multiple values of the same type.",
      "The average uses the total divided by temps.count."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions (Advanced)\nAdvanced features make functions more expressive.\n\nLabels:\n- External/internal: func heat(at value: Int)\n- Omit labels with _: func log(_ value: String)\n\nDefault values:\n    func heatBoost(_ base: Int, intensity: Int = 1) -> Int {\n        return base + (intensity * 100)\n    }\n\nVariadics:\n    func average(_ values: Int...) -> Int {\n        return values.reduce(0, +) / values.count\n    }\n\ninout parameters:\n- Mutate caller values with `&`.\n    func clamp(_ value: inout Int, max: Int) {\n        if value > max { value = max }\n    }\n\nNested helpers:\n- Define small helper functions inside a larger function for clarity.",
    "manualCheck": false,
    "number": 50,
    "requires": [],
    "solution": "func averageTemp(_ temps: Int...) {\n    var total = 0\n    for temp in temps {\n        total += temp\n    }\n    let average = total / temps.count\n    print(average)\n}\n\naverageTemp(1000, 1200, 1400)",
    "starterCode": "// Challenge 50: Variadics\n// Accept multiple temperatures.\n\n// TODO: Create a function 'averageTemp' that takes any number of Ints\n// TODO: Sum the values and divide by how many values there are (integer division)\n// TODO: Print the average\n\n// TODO: Call averageTemp with 1000, 1200, 1400",
    "tier": "mainline",
    "title": "Variadics",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(label param: Type) -> ReturnType { ... }\n- External vs internal labels: func f(external internal: Type)\n- Omit labels with _: func f(_ value: Type)\n- Default values: param: Type = value\n- Variadics: param: Type...\n- inout params mutate caller; call with &value\n- Nested functions are allowed inside functions\n- Tuple return types: -> (min: Int, max: Int)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Mutate a value passed into a function",
    "expectedOutput": "4",
    "fixtureFiles": [],
    "hints": [
      "inout lets a function modify the caller’s variable.",
      "inout arguments are passed with &."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions (Advanced)\nAdvanced features make functions more expressive.\n\nLabels:\n- External/internal: func heat(at value: Int)\n- Omit labels with _: func log(_ value: String)\n\nDefault values:\n    func heatBoost(_ base: Int, intensity: Int = 1) -> Int {\n        return base + (intensity * 100)\n    }\n\nVariadics:\n    func average(_ values: Int...) -> Int {\n        return values.reduce(0, +) / values.count\n    }\n\ninout parameters:\n- Mutate caller values with `&`.\n    func clamp(_ value: inout Int, max: Int) {\n        if value > max { value = max }\n    }\n\nNested helpers:\n- Define small helper functions inside a larger function for clarity.",
    "manualCheck": false,
    "number": 51,
    "requires": [],
    "solution": "func wear(_ durability: inout Int) {\n    durability -= 1\n}\n\nvar durability = 5\nwear(&durability)\nprint(durability)",
    "starterCode": "// Challenge 51: inout Parameters\n// Simulate tool wear.\n\n// TODO: Create a function 'wear' that subtracts 1 from a passed-in Int\n\n// TODO: Create a variable 'durability' = 5\n// TODO: Call wear on durability\n// TODO: Print durability",
    "tier": "mainline",
    "title": "inout Parameters",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(label param: Type) -> ReturnType { ... }\n- External vs internal labels: func f(external internal: Type)\n- Omit labels with _: func f(_ value: Type)\n- Default values: param: Type = value\n- Variadics: param: Type...\n- inout params mutate caller; call with &value\n- Nested functions are allowed inside functions\n- Tuple return types: -> (min: Int, max: Int)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use helper functions inside functions",
    "expectedOutput": "Invalid",
    "fixtureFiles": [],
    "hints": [
      "Nested functions can encapsulate helper logic.",
      "A helper Bool can drive the output choice."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions (Advanced)\nAdvanced features make functions more expressive.\n\nLabels:\n- External/internal: func heat(at value: Int)\n- Omit labels with _: func log(_ value: String)\n\nDefault values:\n    func heatBoost(_ base: Int, intensity: Int = 1) -> Int {\n        return base + (intensity * 100)\n    }\n\nVariadics:\n    func average(_ values: Int...) -> Int {\n        return values.reduce(0, +) / values.count\n    }\n\ninout parameters:\n- Mutate caller values with `&`.\n    func clamp(_ value: inout Int, max: Int) {\n        if value > max { value = max }\n    }\n\nNested helpers:\n- Define small helper functions inside a larger function for clarity.",
    "manualCheck": false,
    "number": 52,
    "requires": [],
    "solution": "func process(_ value: Int) {\n    func isValid(_ value: Int) -> Bool {\n        return value >= 0\n    }\n    if isValid(value) {\n        print(\"OK\")\n    } else {\n        print(\"Invalid\")\n    }\n}\n\nprocess(-1)",
    "starterCode": "// Challenge 52: Nested Functions\n// Validate before processing.\n\n// TODO: Create a function 'process' that takes an Int parameter\n// - defines a nested function isValid(_:) returning Bool\n// - prints \"OK\" if valid, otherwise \"Invalid\"\n// Valid = value >= 0\n\n// TODO: Call process with -1",
    "tier": "mainline",
    "title": "Nested Functions",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Create and call a closure",
    "expectedOutput": "Strike",
    "fixtureFiles": [],
    "hints": [
      "Define a constant with a closure literal: let strike = { ... }",
      "Full form for no params/return: { () -> Void in ... }",
      "No type annotation needed; will be covered later in dedicated challenge.",
      "Call it with parentheses: strike()"
    ],
    "id": "",
    "introduces": [
      "closures"
    ],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 53,
    "requires": [],
    "solution": "let strike = { () -> Void in\n    print(\"Strike\")\n}\n\nstrike()",
    "starterCode": "// Challenge 53: Closure Basics\n// Store a closure in a constant.\n// Note: start fully expanded; later challenges will compress the syntax.\n\n// TODO: Create a closure called strike that prints \"Strike\"\n// TODO: Call the closure",
    "tier": "mainline",
    "title": "Closure Basics",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Pass values into a closure",
    "expectedOutput": "1500",
    "fixtureFiles": [],
    "hints": [
      "Give the closure a parameter list and return type before `in`.",
      "Call the closure and print the result."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 54,
    "requires": [],
    "solution": "let doubleHeat = { (value: Int) -> Int in\n    return value * 2\n}\n\nprint(doubleHeat(750))",
    "starterCode": "// Challenge 54: Closure Parameters\n// Create a closure that transforms a value.\n\n// TODO: Create a closure called doubleHeat that takes an Int\n// and returns the value multiplied by 2\n// TODO: Print doubleHeat(750)",
    "tier": "mainline",
    "title": "Closure Parameters",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Omit the return keyword in a single-expression closure",
    "expectedOutput": "1200",
    "fixtureFiles": [],
    "hints": [
      "Keep the explicit signature, but make the body a single expression.",
      "You can omit `return` when the body is a single expression."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 55,
    "requires": [],
    "solution": "let doubleHeat = { (value: Int) -> Int in\n    value * 2\n}\n\nprint(doubleHeat(600))",
    "starterCode": "// Challenge 55: Implicit Return in Closures\n// Use an explicit signature, but omit return.\n// Compression: keep explicit types, drop the return keyword.\n\n// TODO: Create a closure called 'doubleHeat' that takes an Int\n// and returns the value multiplied by 2\n// TODO: Print doubleHeat(600)",
    "tier": "mainline",
    "title": "Implicit Return in Closures",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Let Swift infer parameter and return types",
    "expectedOutput": "1500",
    "fixtureFiles": [],
    "hints": [
      "Drop the parameter type: { value in ... }",
      "Return is optional for single-expression closures."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 56,
    "requires": [],
    "solution": "let doubleHeat = { value in\n    value * 2\n}\n\nprint(doubleHeat(750))",
    "starterCode": "// Challenge 56: Inferred Closure Types\n// Remove explicit types when they can be inferred.\n// Compression: drop parameter/return types in the closure.\n\n// TODO: Create a closure called 'doubleHeat' using inferred types\n// It should multiply the input by 2\n// TODO: Print doubleHeat(750)",
    "tier": "mainline",
    "title": "Inferred Closure Types",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Use $0 in an assigned closure",
    "expectedOutput": "1400",
    "fixtureFiles": [],
    "hints": [
      "Use shorthand args: { $0 * 2 }",
      "Print the result of calling the closure."
    ],
    "id": "",
    "introduces": [
      "shorthandClosureArgs"
    ],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 57,
    "requires": [],
    "solution": "let doubleHeat = { $0 * 2 }\nprint(doubleHeat(700))",
    "starterCode": "// Challenge 57: Shorthand Closure Syntax I\n// Use $0 in a closure stored in a constant.\n// Compression: replace named parameters with $0.\n\n// TODO: Create a closure called 'doubleHeat' using $0\n// It should multiply the input by 2\n// TODO: Print doubleHeat(700)",
    "tier": "mainline",
    "title": "Shorthand Closure Syntax I",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Bind a closure to a typed constant",
    "expectedOutput": "1800",
    "fixtureFiles": [],
    "hints": [
      "Annotate the constant type: let doubleHeat: (Int) -> Int = ...",
      "Use shorthand args in the body: { $0 * 2 }"
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 58,
    "requires": [],
    "solution": "let doubleHeat: (Int) -> Int = { $0 * 2 }\nprint(doubleHeat(900))",
    "starterCode": "// Challenge 58: Annotated Closure Assignment\n// Use a closure with an explicit type annotation.\n// Compression: move the type to the constant annotation.\n\n// TODO: Create a constant 'doubleHeat' with an explicit function type\n// Use a shorthand closure to multiply the input by 2\n// TODO: Print doubleHeat(900)",
    "tier": "mainline",
    "title": "Annotated Closure Assignment",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Call a function with a closure argument",
    "expectedOutput": "15",
    "fixtureFiles": [],
    "hints": [
      "Pass the closure in the argument list: transform(5, using: { ... })",
      "Use the full explicit closure syntax again (params/return + in).",
      "Multiply the incoming value by 3 inside the closure."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 59,
    "requires": [],
    "solution": "transform(5, using: { (value: Int) -> Int in\n    return value * 3\n})",
    "starterCode": "// Challenge 59: Closure Arguments\n// Call a function that takes a closure.\n// Compression: same closure, new place — now pass it as an argument.\n\nfunc transform(_ value: Int, using closure: (Int) -> Int) {\n    print(closure(value))\n}\n\n// TODO: Call transform with 5 using the full closure argument\n// Multiply the value by 3",
    "tier": "mainline",
    "title": "Closure Arguments",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Use trailing closure syntax",
    "expectedOutput": "15",
    "fixtureFiles": [],
    "hints": [
      "Trailing closure syntax moves the closure outside the parentheses.",
      "Keep the same closure signature; only move its position.",
      "Use a trailing closure call and multiply the value by 3."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 60,
    "requires": [],
    "solution": "transform(5) { (value: Int) -> Int in\n    return value * 3\n}",
    "starterCode": "// Challenge 60: Trailing Closures\n// Use a closure to transform values.\n// Trailing placement: same closure syntax, moved outside the parentheses.\n\nfunc transform(_ value: Int, using closure: (Int) -> Int) {\n    print(closure(value))\n}\n\n// TODO: Call transform with 5 using trailing closure syntax\n// Multiply the value by 3",
    "tier": "mainline",
    "title": "Trailing Closures",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Drop types and return when they can be inferred",
    "expectedOutput": "24",
    "fixtureFiles": [],
    "hints": [
      "Use trailing closure syntax with inferred types.",
      "Multiply the value by 4 in a single expression."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 61,
    "requires": [],
    "solution": "transform(6) { value in\n    return value * 4\n}",
    "starterCode": "// Challenge 61: Inferred Trailing Closures\n// Let Swift infer types in a trailing closure.\n// Compression: trailing closure with inferred types.\n\nfunc transform(_ value: Int, using closure: (Int) -> Int) {\n    print(closure(value))\n}\n\n// TODO: Call transform with 6 using trailing closure syntax\n// Multiply the value by 4\n// Note: You can omit return for a single-expression closure (Challenge 50)",
    "tier": "mainline",
    "title": "Inferred Trailing Closures",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Use $0 for compact closures",
    "expectedOutput": "10",
    "fixtureFiles": [],
    "hints": [
      "Use shorthand args in the trailing closure: { $0 + 6 }",
      "Call apply with 4: apply(4) { ... }"
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 62,
    "requires": [],
    "solution": "apply(4) { $0 + 6 }",
    "starterCode": "// Challenge 62: Shorthand Closure Syntax II\n// Use $0 to shorten a closure.\n// Compression: trailing closure + shorthand args.\n\nfunc apply(_ value: Int, using closure: (Int) -> Int) {\n    print(closure(value))\n}\n\n// TODO: Call apply with 4 and use $0 to add 6",
    "tier": "mainline",
    "title": "Shorthand Closure Syntax II",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Understand closure capture behavior",
    "expectedOutput": "1\n2\n3",
    "fixtureFiles": [],
    "hints": [
      "The returned closure should increment a captured variable and print it.",
      "The returned closure has type () -> Void, so it does not return an Int.",
      "Call the counter three times to print 1, 2, 3."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nClosures are reusable blocks of behavior you can store in variables, pass into\nfunctions, and return from functions. They capture values from their surrounding\nscope, which is why they feel lightweight and flexible.\n\nOverview:\n- Closure literals use braces: { ... }\n- Parameters and return type go before `in`\n- The body is the code after `in`\n- The closure can capture values defined outside it\n\nBasic shape:\n    let greet = { (name: String) -> String in\n        return \"Hello, \\(name)!\"\n    }\n    print(greet(\"Sam\"))\n\nParameters and return types:\n- The type appears after the variable name.\n- The `in` keyword separates the signature from the body.\n    let add: (Int, Int) -> Int = { a, b in\n        return a + b\n    }\n\nType inference:\n- Swift can often infer the parameter and return types.\n- You can omit types once the compiler knows the context.\n    let numbers = [4, 1, 9]\n    let sorted = numbers.sorted(by: { a, b in return a < b })\n\nSingle-expression closures:\n- If the body is a single expression, `return` is optional.\n    let doubled = numbers.map { value in value * 2 }\n\nShorthand argument names:\n- Use $0, $1, ... for unnamed parameters.\n    let sorted2 = numbers.sorted(by: { $0 < $1 })\n\nOperator functions:\n- Many operators are functions you can pass directly.\n    let sorted3 = numbers.sorted(by: <)\n\nTrailing closure syntax:\n- If the closure is the final argument, you can move it outside parentheses.\n    let filtered = numbers.filter { value in value > 3 }\n\nCapturing values:\n- Closures can read and mutate variables from the outer scope.\n    func makeCounter() -> () -> Int {\n        var count = 0\n        return {\n            count += 1\n            return count\n        }\n    }\n\nProgression:\nUse the same task while gradually removing syntax:\n\n1) Full syntax (explicit types + return):\n    let transform = { (value: Int) -> Int in\n        return value * 3\n    }\n\n2) Type inference (drop types when context is clear):\n    let transform: (Int) -> Int = { value in\n        return value * 3\n    }\n\n3) Implicit return (single expression):\n    let transform: (Int) -> Int = { value in\n        value * 3\n    }\n\n4) Shorthand args ($0):\n    let transform: (Int) -> Int = { $0 * 3 }\n\n5) Trailing closure (when passing to a function):\n    func apply(_ value: Int, using closure: (Int) -> Int) {\n        print(closure(value))\n    }\n    apply(5) { value in\n        return value * 3\n    }\n\n6) Operator function (when it reads clearly):\n    let sorted = [3, 1, 2].sorted(by: <)",
    "manualCheck": false,
    "number": 63,
    "requires": [],
    "solution": "func makeCounter() -> () -> Void {\n    var count = 0\n    return {\n        count += 1\n        print(count)\n    }\n}\n\nlet counter = makeCounter()\ncounter()\ncounter()\ncounter()",
    "starterCode": "// Challenge 63: Capturing Values\n// Create a counter function.\n\n// TODO: Create a function 'makeCounter' that returns a closure\n// The closure (type () -> Void) should increment and print an internal count (NOTE: It prints the count; it does not return an Int).\n\n// TODO: Create a counter and call it three times",
    "tier": "mainline",
    "title": "Capturing Values",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Transform values with map",
    "expectedOutput": "[\"T1200\", \"T1500\", \"T1600\"]",
    "fixtureFiles": [],
    "hints": [
      "Map each value to a label string like \"T\\($0)\".",
      "Example: let labels = temps.map { ... }"
    ],
    "id": "",
    "introduces": [
      "map"
    ],
    "layer": "core",
    "lesson": "Lesson: Collection Transforms\nUse higher-order functions to transform data.\n\nOverview:\n- map transforms each element\n- filter keeps matching values\n- reduce combines into one value\n- compactMap unwraps and drops nils\n- flatMap flattens nested collections\n\nExamples:\n    let doubled = values.map { $0 * 2 }\n    let selected = values.filter { $0 > threshold }\n    let total = values.reduce(0, +)\n\nNotes:\n- min()/max() return Optional values.",
    "manualCheck": false,
    "number": 64,
    "requires": [],
    "solution": "let labels = temps.map { \"T\\($0)\" }\nprint(labels)",
    "starterCode": "// Challenge 64: map\n// Transform forge temperatures into strings.\n\nlet temps = [1200, 1500, 1600]\n\n// TODO: Transform each temp into a label like \"T1200\"\n// TODO: Print the resulting array",
    "tier": "mainline",
    "title": "map",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Select values with filter",
    "expectedOutput": "[1500, 1600]",
    "fixtureFiles": [],
    "hints": [
      "Use .filter to keep only values meeting the condition.",
      "Print the filtered array."
    ],
    "id": "",
    "introduces": [
      "filter"
    ],
    "layer": "core",
    "lesson": "Lesson: Collection Transforms\nUse higher-order functions to transform data.\n\nOverview:\n- map transforms each element\n- filter keeps matching values\n- reduce combines into one value\n- compactMap unwraps and drops nils\n- flatMap flattens nested collections\n\nExamples:\n    let doubled = values.map { $0 * 2 }\n    let selected = values.filter { $0 > threshold }\n    let total = values.reduce(0, +)\n\nNotes:\n- min()/max() return Optional values.",
    "manualCheck": false,
    "number": 65,
    "requires": [],
    "solution": "let hot = temps.filter { $0 >= 1500 }\nprint(hot)",
    "starterCode": "// Challenge 65: filter\n// Keep only hot temperatures.\n\nlet temps = [1000, 1500, 1600, 1400]\n\n// TODO: Keep temps >= 1500\n// TODO: Print the filtered array",
    "tier": "mainline",
    "title": "filter",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine values with reduce",
    "expectedOutput": "3600",
    "fixtureFiles": [],
    "hints": [
      "Reduce starts with an initial value: temps.reduce(0) { ... }",
      "Add each temp into the running total."
    ],
    "id": "",
    "introduces": [
      "reduce"
    ],
    "layer": "core",
    "lesson": "Lesson: Collection Transforms\nUse higher-order functions to transform data.\n\nOverview:\n- map transforms each element\n- filter keeps matching values\n- reduce combines into one value\n- compactMap unwraps and drops nils\n- flatMap flattens nested collections\n\nExamples:\n    let doubled = temps.map { $0 * 2 }\n    let hot = temps.filter { $0 >= 1500 }\n    let total = temps.reduce(0, +)\n\nNotes:\n- min()/max() return Optional values.",
    "manualCheck": false,
    "number": 66,
    "requires": [],
    "solution": "let total = temps.reduce(0) { partial, temp in\n    partial + temp\n}\nprint(total)",
    "starterCode": "// Challenge 66: reduce\n// Sum forge temperatures.\n\nlet temps = [1000, 1200, 1400]\n\n// TODO: Compute the total of all temps\n// TODO: Print the total",
    "tier": "mainline",
    "title": "reduce",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Find smallest and largest values",
    "expectedOutput": "1200\n1600",
    "fixtureFiles": [],
    "hints": [
      "Call min() and max(), then use ?? 0 to unwrap.",
      "Print min, then max on separate lines."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Collection Transforms\nUse higher-order functions to transform data.\n\nOverview:\n- map transforms each element\n- filter keeps matching values\n- reduce combines into one value\n- compactMap unwraps and drops nils\n- flatMap flattens nested collections\n\nExamples:\n    let doubled = temps.map { $0 * 2 }\n    let hot = temps.filter { $0 >= 1500 }\n    let total = temps.reduce(0, +)\n\nNotes:\n- min()/max() return Optional values.",
    "manualCheck": false,
    "number": 67,
    "requires": [],
    "solution": "let minTemp = temps.min() ?? 0\nlet maxTemp = temps.max() ?? 0\nprint(minTemp)\nprint(maxTemp)",
    "starterCode": "// Challenge 67: min/max\n// Find the smallest and largest temperatures.\n\nlet temps = [1200, 1500, 1600, 1400]\n\n// TODO: Find the smallest temp (default to 0 if nil)\n// TODO: Find the largest temp (default to 0 if nil)\n// TODO: Print min then max on separate lines",
    "tier": "mainline",
    "title": "min/max",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Remove nil values safely",
    "expectedOutput": "[1200, 1500, 1600]",
    "fixtureFiles": [],
    "hints": [
      "Use compactMap { $0 } to drop nils and unwrap.",
      "Print the resulting [Int]."
    ],
    "id": "",
    "introduces": [
      "compactMap"
    ],
    "layer": "core",
    "lesson": "Lesson: Collection Transforms\nUse higher-order functions to transform data.\n\nOverview:\n- map transforms each element\n- filter keeps matching values\n- reduce combines into one value\n- compactMap unwraps and drops nils\n- flatMap flattens nested collections\n\nExamples:\n    let doubled = temps.map { $0 * 2 }\n    let hot = temps.filter { $0 >= 1500 }\n    let total = temps.reduce(0, +)\n\nNotes:\n- min()/max() return Optional values.",
    "manualCheck": false,
    "number": 68,
    "requires": [],
    "solution": "let cleaned = readings.compactMap { $0 }\nprint(cleaned)",
    "starterCode": "// Challenge 68: compactMap\n// Clean up optional readings.\n\nlet readings: [Int?] = [1200, nil, 1500, nil, 1600]\n\n// TODO: Remove nils and keep only Int values\n// TODO: Print the cleaned array",
    "tier": "mainline",
    "title": "compactMap",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Flatten nested arrays",
    "expectedOutput": "[1, 2, 3, 4, 5]",
    "fixtureFiles": [],
    "hints": [
      "Flatten with batches.flatMap { $0 }.",
      "Print the flattened array."
    ],
    "id": "",
    "introduces": [
      "flatMap"
    ],
    "layer": "core",
    "lesson": "Lesson: Collection Transforms\nUse higher-order functions to transform data.\n\nOverview:\n- map transforms each element\n- filter keeps matching values\n- reduce combines into one value\n- compactMap unwraps and drops nils\n- flatMap flattens nested collections\n\nExamples:\n    let doubled = temps.map { $0 * 2 }\n    let hot = temps.filter { $0 >= 1500 }\n    let total = temps.reduce(0, +)\n\nNotes:\n- min()/max() return Optional values.",
    "manualCheck": false,
    "number": 69,
    "requires": [],
    "solution": "let flat = batches.flatMap { $0 }\nprint(flat)",
    "starterCode": "// Challenge 69: flatMap\n// Flatten batches.\n\nlet batches = [[1, 2], [3], [4, 5]]\n\n// TODO: Flatten the nested arrays into one list\n// TODO: Print the result",
    "tier": "mainline",
    "title": "flatMap",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Typealias\n- typealias Name = ExistingType\n- Useful for readable tuple types",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Improve readability with type aliases",
    "expectedOutput": "1200",
    "fixtureFiles": [],
    "hints": [
      "typealias can make tuple types more readable (e.g., ForgeReading = (temp: Int, time: Int)).",
      "Named tuple fields are accessed with dot syntax (reading.temp)."
    ],
    "id": "",
    "introduces": [
      "typeAlias"
    ],
    "layer": "core",
    "lesson": "Lesson: Typealias\nTypealiases give long types a readable name.\n\nOverview:\n- Use typealias to improve readability.\n- Helpful for tuples, closures, or long generic types.\n\nExample:\n    typealias Reading = (temp: Int, time: Int)\n    let sample: Reading = (temp: 1500, time: 42)",
    "manualCheck": false,
    "number": 70,
    "requires": [],
    "solution": "typealias ForgeReading = (temp: Int, time: Int)\nlet reading: ForgeReading = (temp: 1200, time: 1)\nprint(reading.temp)",
    "starterCode": "// Challenge 70: typealias\n// Create a readable alias.\n\n// TODO: Create a typealias for a reading with temp and time\n// TODO: Create a reading with temp 1200 and time 1\n// TODO: Print the temperature from reading",
    "tier": "mainline",
    "title": "typealias",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Enums\n- enum Name { case a, b }\n- Raw values: enum Name: String { case a }\n- Associated values: case event(Int)\n- Switch extracts values with let bindings\n- where adds an extra condition in a case",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Represent a set of cases",
    "expectedOutput": "iron",
    "fixtureFiles": [],
    "hints": [
      "Enums define a closed set of cases.",
      "switch handles each enum case.",
      "Set metal to .iron so the output matches the expected value."
    ],
    "id": "",
    "introduces": [
      "enums"
    ],
    "layer": "core",
    "lesson": "Lesson: Enums\nEnums define a fixed set of cases.\n\nOverview:\n- Use enums for states, categories, or choices.\n- Switch statements pair well with enums.\n\nRaw values:\n    enum Mode: String { case idle, active }\n    let label = Mode.idle.rawValue\n\nAssociated values:\n    enum Reading { case level(Int) }\n\nSwitching:\n    switch reading {\n    case .level(let amount):\n        print(amount)\n    }",
    "manualCheck": false,
    "number": 71,
    "requires": [],
    "solution": "enum Metal {\n    case iron\n    case gold\n}\n\nlet metal = Metal.iron\n\nswitch metal {\ncase .iron:\n    print(\"iron\")\ncase .gold:\n    print(\"gold\")\n}",
    "starterCode": "// Challenge 71: Enums\n// Represent forge metals.\n\n// TODO: Create an enum 'Metal' with cases 'iron' and 'gold'\n// TODO: Create let metal = Metal.iron\n// TODO: Use a switch to print \"iron\" for .iron and \"gold\" for .gold",
    "tier": "mainline",
    "title": "Enums",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Enums\n- enum Name { case a, b }\n- Raw values: enum Name: String { case a }\n- Associated values: case event(Int)\n- Switch extracts values with let bindings\n- where adds an extra condition in a case",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Represent simple categories",
    "expectedOutput": "iron",
    "fixtureFiles": [],
    "hints": [
      "Declare the enum as Metal: String and use .rawValue to print.",
      "Use a Metal value first, then print its rawValue."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Enums\nEnums define a fixed set of cases.\n\nOverview:\n- Use enums for states, categories, or choices.\n- Switch statements pair well with enums.\n\nRaw values:\n    enum Mode: String { case idle, active }\n    let label = Mode.idle.rawValue\n\nAssociated values:\n    enum Reading { case level(Int) }\n\nSwitching:\n    switch reading {\n    case .level(let amount):\n        print(amount)\n    }",
    "manualCheck": false,
    "number": 72,
    "requires": [],
    "solution": "enum Metal: String {\n    case iron\n    case gold\n}\n\nprint(Metal.iron.rawValue)",
    "starterCode": "// Challenge 72: Enums with Raw Values\n// Represent metals.\n\n// TODO: Create an enum 'Metal' with String raw values ('iron', 'gold')\n// TODO: Create let metal = Metal.iron\n// TODO: Print the string value for metal",
    "tier": "mainline",
    "title": "Enums with Raw Values",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Enums\n- enum Name { case a, b }\n- Raw values: enum Name: String { case a }\n- Associated values: case event(Int)\n- Switch extracts values with let bindings\n- where adds an extra condition in a case",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Represent structured events",
    "expectedOutput": "Temp: 1500\nError: Overheat",
    "fixtureFiles": [],
    "hints": [
      "Associated values let enum cases carry data.",
      "Value bindings in switch extract associated data.",
      "Create both events and switch over each so both lines print in order."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Enums\nEnums define a fixed set of cases.\n\nOverview:\n- Use enums for states, categories, or choices.\n- Switch statements pair well with enums.\n\nRaw values:\n    enum Mode: String { case idle, active }\n    let label = Mode.idle.rawValue\n\nAssociated values:\n    enum Reading { case level(Int) }\n\nSwitching:\n    switch reading {\n    case .level(let amount):\n        print(amount)\n    }",
    "manualCheck": false,
    "number": 73,
    "requires": [],
    "solution": "enum Event {\n    case temperature(Int)\n    case error(String)\n}\n\nlet tempEvent = Event.temperature(1500)\nlet errorEvent = Event.error(\"Overheat\")\n\nswitch tempEvent {\ncase .temperature(let value):\n    print(\"Temp: \\(value)\")\ncase .error(let message):\n    print(\"Error: \\(message)\")\n}\n\nswitch errorEvent {\ncase .temperature(let value):\n    print(\"Temp: \\(value)\")\ncase .error(let message):\n    print(\"Error: \\(message)\")\n}",
    "starterCode": "// Challenge 73: Enums with Associated Values\n// Represent forge events.\n\n// TODO: Create an enum 'Event' with:\n// - temperature(Int)\n// - error(String)\n\n// TODO: Create tempEvent = Event.temperature(1500) and errorEvent = Event.error(\"Overheat\")\n// TODO: Use a switch on each event and print based on the case\n// Use a switch to print:\n// - \"Temp: 1500\" for temperature(1500)\n// - \"Error: Overheat\" for error(\"Overheat\")",
    "tier": "mainline",
    "title": "Enums with Associated Values",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Enums\n- enum Name { case a, b }\n- Raw values: enum Name: String { case a }\n- Associated values: case event(Int)\n- Switch extracts values with let bindings\n- where adds an extra condition in a case",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": [
        "where"
      ]
    },
    "description": "Use switch pattern matching with a where clause on associated values",
    "expectedOutput": "Overheated",
    "fixtureFiles": [],
    "hints": [
      "Start a `switch` on `event` and handle every `Event` case.",
      "For temperature, bind the associated value and use `where` to filter the overheated threshold.",
      "Use a second temperature branch for non-overheated values, and keep error handling separate."
    ],
    "id": "",
    "introduces": [
      "whereClauses"
    ],
    "layer": "core",
    "lesson": "Lesson: Switch where Clauses\nUse `where` in a `switch` case to add an extra condition after pattern matching.\n\nOverview:\n- Match enum cases and bind associated values with `let`.\n- Add `where` when a case needs extra boolean filtering.\n- Order from most specific to most general.\n\nShape:\n    case .temperature(let value) where value >= limit:\n        // specific branch\n\nThen add fallback cases for the same enum case without `where`, plus any remaining enum cases.\n\nWhy this helps:\n- Matching and rule checks stay in one place.\n- You avoid extra nested `if` blocks after a match.",
    "manualCheck": false,
    "number": 74,
    "requires": [],
    "solution": "switch event {\ncase .temperature(let temp) where temp >= 1500:\n    print(\"Overheated\")\ncase .temperature:\n    print(\"Normal\")\ncase .error:\n    print(\"Error\")\n}",
    "starterCode": "// Challenge 74: Enum Pattern Matching\n// Use a switch with a where clause.\n\nenum Event {\n    case temperature(Int)\n    case error(String)\n}\n\nlet event = Event.temperature(1600)\n\n// TODO: Use switch to print \"Overheated\" when temp >= 1500\n// Print \"Normal\" for other temperature events\n// Print \"Error\" for error events",
    "tier": "mainline",
    "title": "Enum Pattern Matching",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Errors\n- Define: enum MyError: Error { case ... }\n- Throwing functions use throws\n- Call with try\n- Handle with do { try ... } catch { ... }\n- try? returns Optional, nil on error",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": [
        "Error",
        "throws",
        "throw",
        "do",
        "try",
        "catch"
      ]
    },
    "description": "Introduce error throwing",
    "expectedOutput": "Error",
    "fixtureFiles": [],
    "hints": [
      "Define an Error type for temperatures outside the forge working range.",
      "Throw when the temperature is outside 1200...1800.",
      "do/try/catch handles thrown errors."
    ],
    "id": "",
    "introduces": [
      "doCatch",
      "throwKeyword",
      "tryKeyword",
      "errorTypes",
      "throwingFunctions",
      "doTryCatch"
    ],
    "layer": "core",
    "lesson": "Lesson: Errors\nThrowing functions signal failure paths explicitly.\n\nOverview:\n- `Error` is a protocol in Swift.\n- `enum ValidationError: Error` means the enum conforms to that protocol, so its cases can be thrown.\n- Mark a function as `throws` when it can fail.\n- Use `throw` inside failing branches.\n- Call throwing work with `try` inside `do/catch`.\n\nShape:\n    enum ValidationError: Error {\n        case outOfRange\n    }\n\n    func validate(_ temp: Int) throws {\n        if temp < 1200 || temp > 1800 {\n            throw ValidationError.outOfRange\n        }\n    }\n\n    do {\n        try validate(1000)\n    } catch {\n        // handle failure path\n    }\n\nOptional try:\n- `try?` converts thrown errors to `nil`.",
    "manualCheck": false,
    "number": 75,
    "requires": [],
    "solution": "enum TempError: Error {\n    case outOfRange\n}\n\nfunc checkTemp(_ temp: Int) throws {\n    if temp < 1200 || temp > 1800 {\n        throw TempError.outOfRange\n    }\n}\n\ndo {\n    try checkTemp(1000)\n} catch {\n    print(\"Error\")\n}",
    "starterCode": "// Challenge 75: Throwing Functions\n// Validate forge temperature.\n\n// TODO: Create an enum TempError: Error with case outOfRange\n// TODO: Create a function 'checkTemp' that throws outside 1200...1800\n// TODO: Call it with 1000 using do/try/catch\n// Print \"Error\" in the catch block",
    "tier": "mainline",
    "title": "Throwing Functions",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Errors\n- Define: enum MyError: Error { case ... }\n- Throwing functions use throws\n- Call with try\n- Handle with do { try ... } catch { ... }\n- try? returns Optional, nil on error",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Convert errors into optionals",
    "expectedOutput": "nil",
    "fixtureFiles": [],
    "hints": [
      "Use try? to convert a thrown error into nil.",
      "Use an out-of-range value (outside 1200...1800) so the optional result is nil."
    ],
    "id": "",
    "introduces": [
      "tryOptional"
    ],
    "layer": "core",
    "lesson": "Lesson: Optional try (`try?`)\n`try?` turns a throwing call into an optional value.\n\nOverview:\n- Success returns `.some(value)`.\n- Failure returns `nil` instead of entering `catch`.\n- This is useful when you only care whether it worked.\n\nShape:\n    let result = try? validate(temp)\n\nWith forge range checks:\n- A temperature like `1500` can return a value.\n- A temperature like `1000` (outside 1200...1800) returns `nil`.\n\nTip:\n- Use `String(describing: result)` when you want to print the optional directly.",
    "manualCheck": false,
    "number": 76,
    "requires": [],
    "solution": "enum TempError: Error {\n    case outOfRange\n}\n\nfunc checkTemp(_ temp: Int) throws -> Int {\n    if temp < 1200 || temp > 1800 {\n        throw TempError.outOfRange\n    }\n\n    return temp\n}\n\nlet result = try? checkTemp(1000)\nprint(String(describing: result))",
    "starterCode": "// Challenge 76: try?\n// Use try? to simplify error handling.\n\n// TODO: Reuse checkTemp from the previous challenge\n// TODO: Make checkTemp return the temperature if valid (1200...1800)\n// TODO: Call it with 1000 using optional try\n// TODO: Print the result (should be nil)",
    "tier": "mainline",
    "title": "try?",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "I/O Basics\n- readLine() returns String?\n- CommandLine.arguments is [String], index 0 is the script\n- File read: String(contentsOfFile: path, encoding: .utf8)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Read forge input from standard input",
    "expectedOutput": "You entered Iron",
    "fixtureFiles": [],
    "hints": [
      "readLine() returns an optional string.",
      "Handle nil with an else branch."
    ],
    "id": "",
    "introduces": [
      "readLine"
    ],
    "layer": "core",
    "lesson": "Lesson: Input & Files\nRead forge data from different sources.\n\nOverview:\n- stdin via readLine() for piped input\n- CLI args via CommandLine.arguments for one-off values\n- Files via String(contentsOfFile:) for batch logs\n\nExamples:\n    let line = readLine() // e.g. \"Iron\"\n    let args = CommandLine.arguments // e.g. [\"script\", \"Iron\"]\n    let text = try? String(contentsOfFile: \"temperatures.txt\")",
    "manualCheck": false,
    "number": 77,
    "requires": [],
    "solution": "if let input = readLine() {\n    let message = \"You entered \\(input)\"\n    print(message)\n} else {\n    print(\"No input\")\n}",
    "starterCode": "// Challenge 77: readLine\n// Read a value from standard input.\n//\n// Forge pipes fixtures/input.txt into stdin, so readLine() reads its first line.\n//\n// Expected output: You entered Iron\n\n// TODO: Read a line from input\n// TODO: If input exists, print \"You entered <input>\"\n// TODO: Otherwise print \"No input\"",
    "stdinFixture": "input.txt",
    "tier": "mainline",
    "title": "ReadLine Input",
    "topic": "general"
  },
  {
    "argsFixture": "args.txt",
    "canonicalId": "",
    "cheatsheet": "I/O Basics\n- readLine() returns String?\n- CommandLine.arguments is [String], index 0 is the script\n- File read: String(contentsOfFile: path, encoding: .utf8)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Read forge input from CommandLine.arguments",
    "expectedOutput": "Iron",
    "fixtureFiles": [],
    "hints": [
      "CommandLine.arguments includes the script name at index 0.",
      "Check the count before accessing args[1]."
    ],
    "id": "",
    "introduces": [
      "commandLineArguments"
    ],
    "layer": "core",
    "lesson": "Lesson: Input & Files\nRead forge data from different sources.\n\nOverview:\n- stdin via readLine() for piped input\n- CLI args via CommandLine.arguments for one-off values\n- Files via String(contentsOfFile:) for batch logs\n\nExamples:\n    let line = readLine() // e.g. \"Iron\"\n    let args = CommandLine.arguments // e.g. [\"script\", \"Iron\"]\n    let text = try? String(contentsOfFile: \"temperatures.txt\")",
    "manualCheck": false,
    "number": 78,
    "requires": [],
    "solution": "if args.count >= 2 {\n    print(args[1])\n} else {\n    print(\"No args\")\n}",
    "starterCode": "// Challenge 78: Command-Line Arguments\n// Read arguments.\n//\n// Forge injects args from fixtures/args.txt into CommandLine.arguments.\n//\n// Expected output: Iron\n\nlet args = CommandLine.arguments\n\n// TODO: If args has at least 2 items, print args[1]\n// Otherwise print \"No args\"\n//\n// Note: This prints only the first argument after the script name.",
    "tier": "mainline",
    "title": "Command-Line Arguments",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "I/O Basics\n- readLine() returns String?\n- CommandLine.arguments is [String], index 0 is the script\n- File read: String(contentsOfFile: path, encoding: .utf8)",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Read forge data from a file on disk",
    "expectedOutput": "3",
    "fixtureFiles": [
      "temperatures.txt"
    ],
    "hints": [
      "Read the file into a String with Foundation.",
      "Split the contents on newline characters."
    ],
    "id": "",
    "introduces": [
      "fileIO"
    ],
    "layer": "core",
    "lesson": "Lesson: Input & Files\nRead forge data from different sources.\n\nOverview:\n- stdin via readLine() for piped input\n- CLI args via CommandLine.arguments for one-off values\n- Files via String(contentsOfFile:) for batch logs\n\nExamples:\n    let line = readLine() // e.g. \"Iron\"\n    let args = CommandLine.arguments // e.g. [\"script\", \"Iron\"]\n    let text = try? String(contentsOfFile: \"temperatures.txt\")",
    "manualCheck": false,
    "number": 79,
    "requires": [],
    "solution": "if let fileContents = try? String(contentsOfFile: path, encoding: .utf8) {\n    let lines = fileContents.split(separator: \"\\n\")\n    print(lines.count)\n} else {\n    print(\"Missing file\")\n}",
    "starterCode": "// Challenge 79: File Read\n// Read a file of temperatures.\n//\n// Forge copies fixtures/temperatures.txt into the workspace folder.\n// Your code reads it by path from the current working directory.\n// Note: This requires Foundation for String(contentsOfFile:).\n//\n// Expected output: 3\n\nimport Foundation\n\nlet path = \"temperatures.txt\"\n\n// TODO: Read the file contents from path\n// TODO: Split the contents into lines\n// TODO: Print the number of lines\n//\n// Expected output: 3",
    "tier": "mainline",
    "title": "File Read",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Check forge temperature readiness and report result",
    "expectedOutput": "Test passed",
    "fixtureFiles": [],
    "hints": [
      "A basic condition can gate a success message."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nConditionals choose between different paths based on Bool expressions.\n\nOverview:\n- `if` runs a block when a condition is true.\n- `else if` checks another condition if the first fails.\n- `else` is the fallback.\n\nBasic shape:\n    if temp >= 1500 {\n        print(\"Overheated\")\n    } else if temp >= 1200 {\n        print(\"Hot\")\n    } else {\n        print(\"Cool\")\n    }\n\nTips:\n- Check the most specific cases first.\n- Keep each condition focused and readable.\n\nTernary operator:\n- condition ? valueIfTrue : valueIfFalse\n    let label = temp >= 1500 ? \"Overheated\" : \"Stable\"",
    "manualCheck": false,
    "number": 80,
    "requires": [],
    "solution": "let temp = 1500\nif temp >= 1200 && temp <= 1800 {\n    print(\"Test passed\")\n}",
    "starterCode": "// Challenge 80: Basic Test\n// Write a basic test case.\n//\n// Steps:\n// 1) From repo root: swift workspace/challenge80.swift\n//\n// Expected output: Test passed\n\n// TODO: Create a temp constant set to 1500\n// TODO: If temp is inside 1200...1800, print \"Test passed\"",
    "tier": "mainline",
    "title": "Basic Test",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine Core 3 concepts in a forge log pipeline",
    "expectedOutput": "3100",
    "fixtureFiles": [],
    "hints": [
      "Combine higher-order functions into a pipeline.",
      "Use Int($0), compactMap, filter, and reduce in stages."
    ],
    "id": "",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Core 3 Integration\nCombine strings, collections, and transforms into a pipeline.\n\nSuggested stages:\n1) Parse or load raw inputs.\n2) Clean and normalize data.\n3) Transform with map/filter/reduce.\n4) Format output with strings.\n\nExample approach:\n- Map temperatures into labels.\n- Filter to the values you need.\n- Reduce or summarize when required.\n\nTip:\n- Print intermediate results while building the pipeline.",
    "manualCheck": false,
    "number": 81,
    "requires": [
      "map",
      "compactMap",
      "filter",
      "reduce"
    ],
    "solution": "let values = lines.map { Int($0) }\nlet temps = values.compactMap { $0 }\nlet hotTemps = temps.filter { $0 >= 1500 }\nlet total = hotTemps.reduce(0) { $0 + $1 }\nprint(total)",
    "starterCode": "// Challenge 81: Integration Challenge\n// Process forge logs with advanced tools.\n// Prereqs: map, compactMap, filter, reduce.\n\nlet lines = [\"1200\", \"x\", \"1500\", \"1600\", \"bad\", \"1400\"]\n\n// TODO: Convert each line to an optional Int\n// TODO: Remove invalid values\n// TODO: Keep only temps >= 1500\n// TODO: Compute the total\n// TODO: Print the total",
    "tier": "mainline",
    "title": "Integration Challenge",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine conditions with &&",
    "expectedOutput": "Safe",
    "fixtureFiles": [],
    "hints": [
      "Require both checks to pass before reporting success.",
      "Add a fallback message for the failing case."
    ],
    "id": "core-extra-safety-check",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nCombine conditions with &&\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 82,
    "requires": [],
    "solution": "if heatLevel >= 3 && hasVentilation {\n    print(\"Safe\")\n} else {\n    print(\"Unsafe\")\n}",
    "starterCode": "// Challenge 82: Safety Check\n// Use && to require two conditions.\n\nlet heatLevel = 3\nlet hasVentilation = true\n\n// TODO: If 'heatLevel' >= 3 AND 'hasVentilation', print \"Safe\"\n// Otherwise print \"Unsafe\"",
    "tier": "extra",
    "title": "Safety Check",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use if/else if/else with ranges",
    "expectedOutput": "Warm",
    "fixtureFiles": [],
    "hints": [
      "Order checks from most specific to most general.",
      "Handle the exact-zero case before broader ranges.",
      "Use a final fallback for anything not matched."
    ],
    "id": "core-extra-heat-levels",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nUse if/else if/else with ranges\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 83,
    "requires": [],
    "solution": "if heatLevel == 0 {\n    print(\"Off\")\n} else if heatLevel <= 2 {\n    print(\"Warm\")\n} else {\n    print(\"Hot\")\n}",
    "starterCode": "// Challenge 83: Heat Levels\n// Categorize a value using if/else if/else.\n\nlet heatLevel = 1\n\n// TODO: If 'heatLevel' == 0, print \"Off\"\n// TODO: Else if 'heatLevel' <= 2, print \"Warm\"\n// TODO: Else print \"Hot\"",
    "tier": "extra",
    "title": "Heat Levels",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Loops\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Count matches in a loop",
    "expectedOutput": "2",
    "fixtureFiles": [],
    "hints": [
      "Use the remainder to detect multiples of 3.",
      "Track how many values match the rule.",
      "Print the count after the loop."
    ],
    "id": "core-extra-count-multiples",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Loops\nCount matches in a loop\n\nOverview:\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 84,
    "requires": [],
    "solution": "for number in numbers {\n    if number % 3 == 0 {\n        count += 1\n    }\n}\n\nprint(count)",
    "starterCode": "// Challenge 84: Count Multiples\n// Count numbers divisible by 3.\n\nlet numbers = [1, 2, 3, 4, 5, 6]\nvar count = 0\n\n// TODO: Loop through 'numbers'\n// TODO: If a number is divisible by 3, increment 'count'\n// TODO: Print 'count'",
    "tier": "extra",
    "title": "Count Multiples",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Loops\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Break when a total reaches a limit",
    "expectedOutput": "3100",
    "fixtureFiles": [],
    "hints": [
      "Maintain a running total as you iterate.",
      "Stop once the total reaches or exceeds the limit.",
      "Print the total after the loop ends."
    ],
    "id": "core-extra-running-total",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Loops\nBreak when a total reaches a limit\n\nOverview:\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 85,
    "requires": [],
    "solution": "for temp in temps {\n    total += temp\n    if total >= 2500 {\n        break\n    }\n}\n\nprint(total)",
    "starterCode": "// Challenge 85: Running Total\n// Add values until the total reaches a limit.\n\nlet temps = [900, 1000, 1200, 1500]\nvar total = 0\n\n// TODO: Loop through 'temps' and add to 'total'\n// TODO: If 'total' >= 2500, break\n// TODO: Print 'total'",
    "tier": "extra",
    "title": "Running Total",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Convert a string to an Int safely",
    "expectedOutput": "Temp: 1500",
    "fixtureFiles": [],
    "hints": [
      "Converting from String to Int yields an optional.",
      "Unwrap the value before building the success message.",
      "Include a fallback message for the failure path."
    ],
    "id": "core-extra-optional-conversion",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nConvert a string to an Int safely\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 86,
    "requires": [],
    "solution": "if let temp = Int(input) {\n    print(\"Temp: \\(temp)\")\n} else {\n    print(\"Invalid\")\n}",
    "starterCode": "// Challenge 86: Optional Conversion\n// Use if let with Int().\n\nlet input = \"1500\"\n\n// TODO: Convert 'input' to an Int using if let\n// TODO: Print \"Temp: <value>\"\n// TODO: Otherwise print \"Invalid\"",
    "tier": "extra",
    "title": "Optional Conversion",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use guard let for early exit",
    "expectedOutput": "Invalid",
    "fixtureFiles": [],
    "hints": [
      "guard let can unwrap and convert in one step.",
      "Exit early before reaching the success print."
    ],
    "id": "core-extra-guard-conversion",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nUse guard let for early exit\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 87,
    "requires": [],
    "solution": "func readTemp(_ value: String?) {\n    guard let value = value, let temp = Int(value) else {\n        print(\"Invalid\")\n        return\n    }\n    print(\"Temp: \\(temp)\")\n}\n\nreadTemp(\"abc\")",
    "starterCode": "// Challenge 87: Guard Conversion\n// Use guard let to unwrap and convert.\n\nfunc readTemp(_ value: String?) {\n    // TODO: Use guard let to unwrap 'value' and convert to Int\n    // Print \"Invalid\" if conversion fails\n    // Otherwise print \"Temp: <value>\"\n}\n\n// TODO: Call 'readTemp' with \"abc\"",
    "tier": "extra",
    "title": "Guard Conversion",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Dictionaries\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Update a dictionary value",
    "expectedOutput": "2",
    "fixtureFiles": [],
    "hints": [
      "Use a defaulted dictionary subscript so the key is safe even if missing.",
      "Increase the iron count by one, then print the updated value."
    ],
    "id": "core-extra-inventory-update",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Dictionaries\nUpdate a dictionary value\n\nOverview:\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 88,
    "requires": [],
    "solution": "inventory[\"Iron\", default: 0] += 1\nprint(inventory[\"Iron\", default: 0])",
    "starterCode": "// Challenge 88: Inventory Update\n// Increment a dictionary value.\n\nvar inventory = [\"Iron\": 1]\n\n// TODO: Increment the count for \"Iron\" by 1\n// TODO: Print the new count",
    "tier": "extra",
    "title": "Inventory Update",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Arrays\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Remove an element by index",
    "expectedOutput": "[\"Iron\", \"Copper\"]",
    "fixtureFiles": [],
    "hints": [
      "Remove by index rather than by value.",
      "Print the updated array afterward."
    ],
    "id": "core-extra-remove-from-array",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Arrays\nRemove an element by index\n\nOverview:\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 89,
    "requires": [],
    "solution": "metals.remove(at: 1)\nprint(metals)",
    "starterCode": "// Challenge 89: Remove from Array\n// Remove one item and print the result.\n\nvar metals = [\"Iron\", \"Gold\", \"Copper\"]\n\n// TODO: Remove \"Gold\"\n// TODO: Print 'metals'",
    "tier": "extra",
    "title": "Remove from Array",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Return true or false from a function",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "Signature example: isOverheated(temp: Int) -> Bool.",
      "Return the result of a comparison and print it."
    ],
    "id": "core-extra-boolean-return",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nReturn true or false from a function\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 90,
    "requires": [],
    "solution": "func isOverheated(temp: Int) -> Bool {\n    return temp >= 1500\n}\n\nprint(isOverheated(temp: 1600))",
    "starterCode": "// Challenge 90: Boolean Return\n// Return a Bool from a function.\n\n// TODO: Create a function that returns true when temp >= 1500\n// TODO: Call 'isOverheated' with 1600, then print",
    "tier": "extra",
    "title": "Boolean Return",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Call one function from another",
    "expectedOutput": "T1200",
    "fixtureFiles": [],
    "hints": [
      "Signature example: label(temp: Int) -> String.",
      "Signature example: printLabel(for temp: Int).",
      "Call the wrapper to trigger printing."
    ],
    "id": "core-extra-helper-function",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nCall one function from another\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 91,
    "requires": [],
    "solution": "func label(temp: Int) -> String {\n    return \"T\\(temp)\"\n}\n\nfunc printLabel(for temp: Int) {\n    print(label(temp: temp))\n}\n\nprintLabel(for: 1200)",
    "starterCode": "// Challenge 91: Helper Function\n// Use a helper to build a message.\n\n// TODO: Create a helper that returns a label like \"T<temp>\"\n// TODO: Create a function that prints the helper’s label\n// TODO: Call 'printLabel' with 1200",
    "tier": "extra",
    "title": "Helper Function",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Branch on a Bool with if/else",
    "expectedOutput": "Refuel needed",
    "fixtureFiles": [],
    "hints": [
      "Use a simple true/false branch to pick a message."
    ],
    "id": "core-extra-fuel-warning",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nBranch on a Bool with if/else\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 92,
    "requires": [],
    "solution": "if hasFuel {\n    print(\"Fuel ready\")\n} else {\n    print(\"Refuel needed\")\n}",
    "starterCode": "// Challenge 92: Fuel Warning\n// Use if/else with a Bool.\n\nlet hasFuel = false\n\n// TODO: If 'hasFuel' is true, print \"Fuel ready\"\n// TODO: Otherwise print \"Refuel needed\"",
    "tier": "extra",
    "title": "Fuel Warning",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine conditions with ||",
    "expectedOutput": "Ignite",
    "fixtureFiles": [],
    "hints": [
      "Allow either condition to trigger the success path."
    ],
    "id": "core-extra-override-switch",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nCombine conditions with ||\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 93,
    "requires": [],
    "solution": "if hasFuel || emergencyOverride {\n    print(\"Ignite\")\n} else {\n    print(\"Hold\")\n}",
    "starterCode": "// Challenge 93: Override Switch\n// Use || to allow either condition.\n\nlet hasFuel = false\nlet emergencyOverride = true\n\n// TODO: If 'hasFuel' OR 'emergencyOverride', print \"Ignite\"\n// TODO: Otherwise print \"Hold\"",
    "tier": "extra",
    "title": "Override Switch",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use ! to invert a Bool",
    "expectedOutput": "Heating",
    "fixtureFiles": [],
    "hints": [
      "Invert the Bool to test the opposite case."
    ],
    "id": "core-extra-negation-drill",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nUse ! to invert a Bool\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 94,
    "requires": [],
    "solution": "if !isCooling {\n    print(\"Heating\")\n} else {\n    print(\"Cooling\")\n}",
    "starterCode": "// Challenge 94: Negation Drill\n// Use ! to flip a Bool condition.\n\nlet isCooling = false\n\n// TODO: If NOT 'isCooling', print \"Heating\"\n// TODO: Otherwise print \"Cooling\"",
    "tier": "extra",
    "title": "Negation Drill",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use the ternary operator",
    "expectedOutput": "Warm",
    "fixtureFiles": [],
    "hints": [
      "A ternary chooses between two values based on a condition."
    ],
    "id": "core-extra-ternary-warm-up",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nUse the ternary operator\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 95,
    "requires": [],
    "solution": "let status = heatLevel >= 3 ? \"Hot\" : \"Warm\"\nprint(status)",
    "starterCode": "// Challenge 95: Ternary Warm-up\n// Use ?: to choose a value.\n\nlet heatLevel = 2\n\n// TODO: Use a ternary to set 'status' to \"Hot\" when 'heatLevel' >= 3, else \"Warm\"\n// TODO: Print 'status'",
    "tier": "extra",
    "title": "Ternary Warm-up",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Loops\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Loop over a range with for-in",
    "expectedOutput": "Step 1\nStep 2\nStep 3",
    "fixtureFiles": [],
    "hints": [
      "Use a closed range to include the final step.",
      "Insert the loop value into the output text."
    ],
    "id": "core-extra-heat-steps",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Loops\nLoop over a range with for-in\n\nOverview:\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 96,
    "requires": [],
    "solution": "for step in 1...steps {\n    print(\"Step \\(step)\")\n}",
    "starterCode": "// Challenge 96: Heat Steps\n// Use a for-in loop over a range.\n\nlet steps = 3\n\n// TODO: Loop from 1 to 'steps' inclusive\n// TODO: Print \"Step <n>\" each time",
    "tier": "extra",
    "title": "Heat Steps",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Loops\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use a while loop to count down",
    "expectedOutput": "3\n2\n1",
    "fixtureFiles": [],
    "hints": [
      "Update the loop variable so the loop can end."
    ],
    "id": "core-extra-cooldown-countdown",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Loops\nUse a while loop to count down\n\nOverview:\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 97,
    "requires": [],
    "solution": "while level > 0 {\n    print(level)\n    level -= 1\n}",
    "starterCode": "// Challenge 97: Cooldown Countdown\n// Use a while loop to count down.\n\nvar level = 3\n\n// TODO: While 'level' is greater than 0, print 'level' and subtract 1",
    "tier": "extra",
    "title": "Cooldown Countdown",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Loops\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use repeat-while for at least one run",
    "expectedOutput": "Attempt 1\nAttempt 2",
    "fixtureFiles": [],
    "hints": [
      "repeat-while runs before checking the condition.",
      "Stop after two prints by checking the counter."
    ],
    "id": "core-extra-repeat-ignite",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Loops\nUse repeat-while for at least one run\n\nOverview:\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 98,
    "requires": [],
    "solution": "repeat {\n    attempts += 1\n    print(\"Attempt \\(attempts)\")\n} while attempts < 2",
    "starterCode": "// Challenge 98: Repeat Ignite\n// Use repeat-while to run at least once.\n\nvar attempts = 0\n\n// TODO: Use repeat-while to print \"Attempt <n>\" twice",
    "tier": "extra",
    "title": "Repeat Ignite",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Loops\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use continue and break",
    "expectedOutput": "2",
    "fixtureFiles": [],
    "hints": [
      "Skip unwanted values before incrementing the count.",
      "Stop once you have processed the required number."
    ],
    "id": "core-extra-skip-weak-ore",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Loops\nUse continue and break\n\nOverview:\n- for value in collection { ... }\n- for i in 1...5 (closed) or 1..<5 (half-open)\n- while condition { ... }\n- repeat { ... } while condition\n- break stops a loop; continue skips ahead\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 99,
    "requires": [],
    "solution": "for strength in strengths {\n    if strength == 0 {\n        continue\n    }\n    processed += 1\n    if processed == 2 {\n        break\n    }\n}\n\nprint(processed)",
    "starterCode": "// Challenge 99: Skip Weak Ore\n// Use continue and break.\n\nlet strengths = [1, 2, 0, 3]\nvar processed = 0\n\n// TODO: Loop through 'strengths'\n// TODO: Skip values that are 0\n// TODO: Count 'processed' values\n// TODO: Stop after processing 2 values\n// TODO: Print 'processed'",
    "tier": "extra",
    "title": "Skip Weak Ore",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Arrays\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Append to an array and count it",
    "expectedOutput": "2",
    "fixtureFiles": [],
    "hints": [
      "Add one element to the array before printing.",
      "Use metals.count to get the number of elements."
    ],
    "id": "core-extra-stock-count",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Arrays\nAppend to an array and count it\n\nOverview:\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 100,
    "requires": [],
    "solution": "metals.append(\"Gold\")\nprint(metals.count)",
    "starterCode": "// Challenge 100: Stock Count\n// Use append and count.\n\nvar metals = [\"Iron\"]\n\n// TODO: Append \"Gold\" to 'metals'\n// TODO: Print how many metals are in the list",
    "tier": "extra",
    "title": "Stock Count",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Arrays\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use first with a default value",
    "expectedOutput": "Iron",
    "fixtureFiles": [],
    "hints": [
      "first yields an optional; use metals.first ?? \"None\"."
    ],
    "id": "core-extra-first-ore",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Arrays\nUse first with a default value\n\nOverview:\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 101,
    "requires": [],
    "solution": "let firstMetal = metals.first ?? \"None\"\nprint(firstMetal)",
    "starterCode": "// Challenge 101: First Ore\n// Access the first element safely.\n\nlet metals = [\"Iron\", \"Gold\"]\n\n// TODO: Set 'firstMetal' to the first metal, using \"None\" as a default\n// TODO: Print 'firstMetal'",
    "tier": "extra",
    "title": "First Ore",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Sets\n- Type syntax: Set<Element>\n- Literal: Set([1, 2, 3])\n- Unordered and unique\n- Count: set.count",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Insert and check a set",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "Inserting a duplicate does not change a set.",
      "Check membership with contains before printing."
    ],
    "id": "core-extra-unique-ingots",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Sets\nInsert and check a set\n\nOverview:\n- Type syntax: Set<Element>\n- Literal: Set([1, 2, 3])\n- Unordered and unique\n- Count: set.count\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 102,
    "requires": [],
    "solution": "ingots.insert(\"Iron\")\ningots.insert(\"Gold\")\nprint(ingots.contains(\"Gold\"))",
    "starterCode": "// Challenge 102: Unique Ingots\n// Use a set to track unique values.\n\nvar ingots: Set<String> = [\"Iron\"]\n\n// TODO: Insert \"Iron\" and \"Gold\" into 'ingots'\n// TODO: Print whether the set contains \"Gold\"",
    "tier": "extra",
    "title": "Unique Ingots",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Dictionaries\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Update dictionary values and count keys",
    "expectedOutput": "2",
    "fixtureFiles": [],
    "hints": [
      "Use a defaulted subscript to increment safely.",
      "Add a new key with its starting value.",
      "Use fuel.keys.count to count keys after updates."
    ],
    "id": "core-extra-fuel-ledger",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Dictionaries\nUpdate dictionary values and count keys\n\nOverview:\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 103,
    "requires": [],
    "solution": "fuel[\"Coal\", default: 0] += 1\nfuel[\"Charcoal\"] = 0\nprint(fuel.keys.count)",
    "starterCode": "// Challenge 103: Fuel Ledger\n// Update values in a dictionary.\n\nvar fuel = [\"Coal\": 2]\n\n// TODO: Increase 'Coal' by 1 using a default value\n// TODO: Add \"Charcoal\" with a value of 0\n// TODO: Print the number of keys in fuel",
    "tier": "extra",
    "title": "Fuel Ledger",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Arrays\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Build labels while iterating an array",
    "expectedOutput": "[\"Ore: Iron\", \"Ore: Gold\"]",
    "fixtureFiles": [],
    "hints": [
      "Build each label while iterating the array.",
      "Use interpolation to format each label."
    ],
    "id": "core-extra-iterate-ores",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Arrays\nBuild labels while iterating an array\n\nOverview:\n- Type syntax: [Element]\n- Literal: [1, 2, 3]\n- Count: array.count\n- Append: array.append(value)\n- Access by index: array[0]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 104,
    "requires": [],
    "solution": "for ore in ores {\n    labels.append(\"Ore: \\(ore)\")\n}\n\nprint(labels)",
    "starterCode": "// Challenge 104: Iterate Ores\n// Build a new array while iterating.\n\nlet ores = [\"Iron\", \"Gold\"]\nvar labels: [String] = []\n\n// TODO: Loop through 'ores' and append \"Ore: <name>\" to 'labels'\n// TODO: Print 'labels'",
    "tier": "extra",
    "title": "Iterate Ores",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Dictionaries\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Sum dictionary values",
    "expectedOutput": "3",
    "fixtureFiles": [],
    "hints": [
      "Dictionary iteration gives key/value pairs.",
      "Add the values into a running total before printing."
    ],
    "id": "core-extra-iterate-ledger",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Dictionaries\nSum dictionary values\n\nOverview:\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 105,
    "requires": [],
    "solution": "for (_, count) in ledger {\n    total += count\n}\n\nprint(total)",
    "starterCode": "// Challenge 105: Iterate Ledger\n// Sum values in a dictionary.\n\nlet ledger = [\"Iron\": 2, \"Gold\": 1]\nvar total = 0\n\n// TODO: Loop through 'ledger' and add each count to 'total'\n// TODO: Print 'total'",
    "tier": "extra",
    "title": "Iterate Ledger",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Define a function with one parameter",
    "expectedOutput": "Heat: 1500",
    "fixtureFiles": [],
    "hints": [
      "Define a function that accepts one Int parameter.",
      "Print the value inside the function using interpolation."
    ],
    "id": "core-extra-announce-heat",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nDefine a function with one parameter\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 106,
    "requires": [],
    "solution": "func announceHeat(level: Int) {\n    print(\"Heat: \\(level)\")\n}\n\nannounceHeat(level: 1500)",
    "starterCode": "// Challenge 106: Announce Heat\n// Define a function with one parameter.\n\n// TODO: Create a function 'announceHeat' that takes an Int 'level'\n// TODO: Inside, print \"Heat: <level>\"\n// TODO: Call 'announceHeat' with 1500",
    "tier": "extra",
    "title": "Announce Heat",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Define a function with two parameters",
    "expectedOutput": "Iron + Carbon",
    "fixtureFiles": [],
    "hints": [
      "Use two String parameters in a single print line.",
      "Signature example: combine(metal: String, additive: String).",
      "Call the function with two arguments."
    ],
    "id": "core-extra-combine-alloy",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nDefine a function with two parameters\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 107,
    "requires": [],
    "solution": "func combine(metal: String, additive: String) {\n    print(\"\\(metal) + \\(additive)\")\n}\n\ncombine(metal: \"Iron\", additive: \"Carbon\")",
    "starterCode": "// Challenge 107: Combine Alloy\n// Define a function with two parameters.\n\n// TODO: Create a function 'combine' that takes metal and additive\n// TODO: Print \"<metal> + <additive>\"\n// TODO: Call 'combine' with \"Iron\" and \"Carbon\"",
    "tier": "extra",
    "title": "Combine Alloy",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Return a value from a function",
    "expectedOutput": "15",
    "fixtureFiles": [],
    "hints": [
      "Return the computed value from the function.",
      "Print the result of calling the function."
    ],
    "id": "core-extra-return-weight",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nReturn a value from a function\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 108,
    "requires": [],
    "solution": "func totalWeight(ingots: Int, weightPerIngot: Int) -> Int {\n    return ingots * weightPerIngot\n}\n\nprint(totalWeight(ingots: 3, weightPerIngot: 5))",
    "starterCode": "// Challenge 108: Return Weight\n// Return an Int from a function.\n\n// TODO: Create a function 'totalWeight' that returns 'ingots' * 'weightPerIngot'\n// TODO: Call 'totalWeight' with 3 and 5, then print",
    "tier": "extra",
    "title": "Return Weight",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use a function that returns a String",
    "expectedOutput": "Batch-7",
    "fixtureFiles": [],
    "hints": [
      "Return a string built with interpolation.",
      "Call makeLabel(id: 7) and print the result."
    ],
    "id": "core-extra-label-maker",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nUse a function that returns a String\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 109,
    "requires": [],
    "solution": "func makeLabel(id: Int) -> String {\n    return \"Batch-\\(id)\"\n}\n\nprint(makeLabel(id: 7))",
    "starterCode": "// Challenge 109: Label Maker\n// Return a String from a function.\n\n// TODO: Create a function 'makeLabel' that returns \"Batch-<id>\"\n// TODO: Print the label for id 7",
    "tier": "extra",
    "title": "Label Maker",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use ?? with an optional",
    "expectedOutput": "1200",
    "fixtureFiles": [],
    "hints": [
      "Nil coalescing uses a fallback when the optional is nil.",
      "Print the resulting value."
    ],
    "id": "core-extra-coalesce-default",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nUse ?? with an optional\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 110,
    "requires": [],
    "solution": "let value = reading ?? 1200\nprint(value)",
    "starterCode": "// Challenge 110: Coalesce Default\n// Provide a default with ??.\n\nlet reading: Int? = nil\n\n// TODO: Use ?? to set 'value' to 1200 if 'reading' is nil\n// TODO: Print 'value'",
    "tier": "extra",
    "title": "Coalesce Default",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Unwrap an optional Bool",
    "expectedOutput": "Unknown",
    "fixtureFiles": [],
    "hints": [
      "Use if let to unwrap the optional Bool.",
      "Provide an else path for the nil case."
    ],
    "id": "core-extra-optional-bool-check",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nUnwrap an optional Bool\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 111,
    "requires": [],
    "solution": "if let ready = isReady {\n    print(\"Ready: \\(ready)\")\n} else {\n    print(\"Unknown\")\n}",
    "starterCode": "// Challenge 111: Optional Bool Check\n// Use if let with an optional Bool.\n\nlet isReady: Bool? = nil\n\n// TODO: If 'isReady' has a value, print \"Ready: <value>\"\n// TODO: Otherwise print \"Unknown\"",
    "tier": "extra",
    "title": "Optional Bool Check",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use count on a String",
    "expectedOutput": "4",
    "fixtureFiles": [],
    "hints": [
      "Use alloyName.count to get the length."
    ],
    "id": "core-extra-string-count",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nUse count on a String\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 112,
    "requires": [],
    "solution": "print(alloyName.count)",
    "starterCode": "// Challenge 112: String Count\n// Use count on a String.\n\nlet alloyName = \"Iron\"\n\n// TODO: Print the length of alloyName",
    "tier": "extra",
    "title": "String Count",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Check if a String contains text",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "contains returns true or false based on a match."
    ],
    "id": "core-extra-string-contains",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nCheck if a String contains text\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 113,
    "requires": [],
    "solution": "print(label.contains(\"Gold\"))",
    "starterCode": "// Challenge 113: String Contains\n// Use contains to search.\n\nlet label = \"Gold Ingot\"\n\n// TODO: Print whether 'label' contains \"Gold\"",
    "tier": "extra",
    "title": "String Contains",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Uppercase a String",
    "expectedOutput": "FORGE",
    "fixtureFiles": [],
    "hints": [
      "Use code.uppercased() to get the uppercase string."
    ],
    "id": "core-extra-case-shift",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nUppercase a String\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 114,
    "requires": [],
    "solution": "print(code.uppercased())",
    "starterCode": "// Challenge 114: Case Shift\n// Use uppercased().\n\nlet code = \"Forge\"\n\n// TODO: Print the uppercase version of code",
    "tier": "extra",
    "title": "Case Shift",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Check a String prefix",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "hasPrefix returns true when the text starts with a prefix."
    ],
    "id": "core-extra-prefix-check",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nCheck a String prefix\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 115,
    "requires": [],
    "solution": "print(line.hasPrefix(\"TEMP\"))",
    "starterCode": "// Challenge 115: Prefix Check\n// Use hasPrefix.\n\nlet line = \"TEMP 1500\"\n\n// TODO: Print whether 'line' has prefix \"TEMP\"",
    "tier": "extra",
    "title": "Prefix Check",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Check a String suffix",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "hasSuffix returns true when the text ends with a suffix."
    ],
    "id": "core-extra-suffix-check",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nCheck a String suffix\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 116,
    "requires": [],
    "solution": "print(line.hasSuffix(\"IRON\"))",
    "starterCode": "// Challenge 116: Suffix Check\n// Use hasSuffix.\n\nlet line = \"ALLOY-IRON\"\n\n// TODO: Print whether 'line' has suffix \"IRON\"",
    "tier": "extra",
    "title": "Suffix Check",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Split a String and count parts",
    "expectedOutput": "2",
    "fixtureFiles": [],
    "hints": [
      "Use report.split(separator: \" \") to break the string."
    ],
    "id": "core-extra-split-words",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nSplit a String and count parts\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 117,
    "requires": [],
    "solution": "let parts = report.split(separator: \" \")\nprint(parts.count)",
    "starterCode": "// Challenge 117: Split Words\n// Split a String into parts.\n\nlet report = \"TEMP 1500\"\n\n// TODO: Print the number of words in report",
    "tier": "extra",
    "title": "Split Words",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use a comparison operator",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "Comparisons evaluate to true or false."
    ],
    "id": "core-extra-heat-comparison",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nUse a comparison operator\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 118,
    "requires": [],
    "solution": "print(heatLevel >= 1500)",
    "starterCode": "// Challenge 118: Heat Comparison\n// Compare numeric values.\n\nlet heatLevel = 1600\n\n// TODO: Print whether 'heatLevel' >= 1500",
    "tier": "extra",
    "title": "Heat Comparison",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Compare two Strings",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "Strings can be compared for equality or inequality."
    ],
    "id": "core-extra-not-equal-check",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nCompare two Strings\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 119,
    "requires": [],
    "solution": "print(a != b)",
    "starterCode": "// Challenge 119: Not Equal Check\n// Use != with Strings.\n\nlet a = \"Iron\"\nlet b = \"Gold\"\n\n// TODO: Print whether 'a' != 'b'",
    "tier": "extra",
    "title": "Not Equal Check",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Conditionals\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use < with Ints",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "The < operator checks whether one value is lower than another."
    ],
    "id": "core-extra-lower-than",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Conditionals\nUse < with Ints\n\nOverview:\n- if/else if/else chooses branches\n- Ternary: condition ? valueIfTrue : valueIfFalse\n- switch matches cases; default for non-exhaustive\n- switch cases can match ranges and multiple values\n- where adds an extra check in switch\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 120,
    "requires": [],
    "solution": "print(temp < 1500)",
    "starterCode": "// Challenge 120: Lower Than\n// Use < with Ints.\n\nlet temp = 1400\n\n// TODO: Print whether 'temp' < 1500",
    "tier": "extra",
    "title": "Lower Than",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Ranges\n- Closed: 1...3 includes the end\n- Half-open: 1..<3 excludes the end\n- Used in for-in loops and switch cases",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Loop with 1..<n",
    "expectedOutput": "1\n2",
    "fixtureFiles": [],
    "hints": [
      "Use 1..<end for an open range."
    ],
    "id": "core-extra-open-range-loop",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Ranges\nLoop with 1..<n\n\nOverview:\n- Closed: 1...3 includes the end\n- Half-open: 1..<3 excludes the end\n- Used in for-in loops and switch cases\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 121,
    "requires": [],
    "solution": "for value in 1..<end {\n    print(value)\n}",
    "starterCode": "// Challenge 121: Open Range Loop\n// Use an open range with for-in.\n\nlet end = 3\n\n// TODO: Loop from 1 up to (but not including) 'end'\n// TODO: Print each number",
    "tier": "extra",
    "title": "Open Range Loop",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Ranges\n- Closed: 1...3 includes the end\n- Half-open: 1..<3 excludes the end\n- Used in for-in loops and switch cases",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Sum values in 1...n",
    "expectedOutput": "6",
    "fixtureFiles": [],
    "hints": [
      "A closed range includes the upper bound."
    ],
    "id": "core-extra-closed-range-sum",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Ranges\nSum values in 1...n\n\nOverview:\n- Closed: 1...3 includes the end\n- Half-open: 1..<3 excludes the end\n- Used in for-in loops and switch cases\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 122,
    "requires": [],
    "solution": "for value in 1...end {\n    total += value\n}\n\nprint(total)",
    "starterCode": "// Challenge 122: Closed Range Sum\n// Sum a closed range.\n\nlet end = 3\nvar total = 0\n\n// TODO: Loop from 1 through 'end' and add to 'total'\n// TODO: Print 'total'",
    "tier": "extra",
    "title": "Closed Range Sum",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Ranges\n- Closed: 1...3 includes the end\n- Half-open: 1..<3 excludes the end\n- Used in for-in loops and switch cases",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use 0..<count with an array",
    "expectedOutput": "Iron\nGold\nCopper",
    "fixtureFiles": [],
    "hints": [
      "Use 0..<metals.count to cover valid indices.",
      "Access elements by index inside the loop."
    ],
    "id": "core-extra-index-range",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Ranges\nUse 0..<count with an array\n\nOverview:\n- Closed: 1...3 includes the end\n- Half-open: 1..<3 excludes the end\n- Used in for-in loops and switch cases\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 123,
    "requires": [],
    "solution": "for index in 0..<metals.count {\nprint(metals[index])\n}",
    "starterCode": "// Challenge 123: Index Range\n// Loop with array indices.\n\nlet metals = [\"Iron\", \"Gold\", \"Copper\"]\n\n// TODO: Loop over indices of the metals array\n// TODO: Print each metal",
    "tier": "extra",
    "title": "Index Range",
    "topic": "loops"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Math Operators\n- +, -, *, / for arithmetic\n- % for remainder\n- Compound assignment: +=, -=, *=, /=",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Compare integer and floating division",
    "expectedOutput": "3\n3.5",
    "fixtureFiles": [],
    "hints": [
      "Int division truncates the remainder.",
      "Convert to Double before dividing to keep the fraction."
    ],
    "id": "core-extra-number-conversion",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Math Operators\nCompare integer and floating division\n\nOverview:\n- +, -, *, / for arithmetic\n- % for remainder\n- Compound assignment: +=, -=, *=, /=\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 245,
    "requires": [],
    "solution": "print(a / b)\nprint(Double(a) / Double(b))",
    "starterCode": "// Challenge 245: Number Conversion\n// Compare integer and floating division.\n\nlet a = 7\nlet b = 2\n\n// TODO: Print a / b\n// TODO: Convert to Double and print the fractional result",
    "tier": "extra",
    "title": "Number Conversion",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Convert a numeric string safely",
    "expectedOutput": "Temp: 1500",
    "fixtureFiles": [],
    "hints": [
      "Int(text) returns an optional.",
      "Unwrap before printing the success message."
    ],
    "id": "core-extra-string-to-int",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nConvert a numeric string safely\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 246,
    "requires": [
      "optionalBinding"
    ],
    "solution": "if let value = Int(text) {\n    print(\"Temp: \\(value)\")\n}",
    "starterCode": "// Challenge 246: String to Int\n// Convert a numeric string safely.\n\nlet text = \"1500\"\n\n// TODO: Convert text to an Int with if let\n// TODO: Print \"Temp: 1500\"",
    "tier": "extra",
    "title": "String to Int",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Dictionaries\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Update counts with default values",
    "expectedOutput": "Iron: 3\nGold: 1",
    "fixtureFiles": [],
    "hints": [
      "Use a defaulted subscript to update both counts.",
      "Print each count on its own line."
    ],
    "id": "core-extra-dictionary-default-update",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Dictionaries\nUpdate counts with default values\n\nOverview:\n- Type syntax: [Key: Value]\n- Subscript returns Optional: dict[key]\n- Iterate: for (key, value) in dict { ... }\n- keys and values are collections\n- keys.sorted() produces a stable order\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 247,
    "requires": [],
    "solution": "inventory[\"Iron\", default: 0] += 1\ninventory[\"Gold\", default: 0] += 1\nprint(\"Iron: \\(inventory[\"Iron\", default: 0])\")\nprint(\"Gold: \\(inventory[\"Gold\", default: 0])\")",
    "starterCode": "// Challenge 247: Dictionary Default Update\n// Update counts with default values.\n\nvar inventory = [\"Iron\": 2]\n\n// TODO: Add 1 to \"Iron\" using default:\n// TODO: Add 1 to \"Gold\" using default:\n// TODO: Print \"Iron: 3\" then \"Gold: 1\"",
    "tier": "extra",
    "title": "Dictionary Default Update",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Sets\n- Type syntax: Set<Element>\n- Literal: Set([1, 2, 3])\n- Unordered and unique\n- Count: set.count",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine and intersect sets",
    "expectedOutput": "[1, 2, 3, 4]\n[3]",
    "fixtureFiles": [],
    "hints": [
      "Use union and intersection, then call sorted().",
      "union combines unique values; intersection keeps shared values."
    ],
    "id": "core-extra-set-operations",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Sets\nCombine and intersect sets\n\nOverview:\n- Type syntax: Set<Element>\n- Literal: Set([1, 2, 3])\n- Unordered and unique\n- Count: set.count\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 248,
    "requires": [],
    "solution": "print(a.union(b).sorted())\nprint(a.intersection(b).sorted())",
    "starterCode": "// Challenge 248: Set Operations\n// Combine and intersect sets.\n\nlet a: Set<Int> = [1, 2, 3]\nlet b: Set<Int> = [3, 4]\n\n// TODO: Print the union of a and b (sorted)\n// TODO: Print the intersection of a and b (sorted)",
    "tier": "extra",
    "title": "Set Operations",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Basics\n- count returns the number of elements\n- isEmpty returns Bool\n- first returns Optional\n- keys.count returns number of keys",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Sort values ascending and descending",
    "expectedOutput": "[1200, 1500, 1600]\n[1600, 1500, 1200]",
    "fixtureFiles": [],
    "hints": [
      "Use sorted() for ascending order.",
      "Use reversed() and wrap in Array for descending order."
    ],
    "id": "core-extra-sorting-basics",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Collection Basics\nSort values ascending and descending\n\nOverview:\n- count returns the number of elements\n- isEmpty returns Bool\n- first returns Optional\n- keys.count returns number of keys\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 249,
    "requires": [],
    "solution": "print(temps.sorted())\nprint(Array(temps.sorted().reversed()))",
    "starterCode": "// Challenge 249: Sorting Basics\n// Sort values ascending and descending.\n\nlet temps = [1500, 1200, 1600]\n\n// TODO: Print temps in ascending order\n// TODO: Print temps in descending order",
    "tier": "extra",
    "title": "Sorting Basics",
    "topic": "collections"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Booleans\n- Bool values are true or false\n- Comparisons return Bool\n- Logical operators: &&, ||, !",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine comparisons with &&",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "Put the readiness rule in a single expression.",
      "Assign the expression to a constant, then print it."
    ],
    "id": "core-extra-boolean-flags",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Booleans & Logic\nA Bool stores `true` or `false`. Comparisons produce Bool values.\n\nOverview:\n- Use comparison operators to build conditions.\n- Combine conditions with logical operators.\n\nComparison operators:\n- ==, !=, <, >, <=, >=\n    let hot = temp >= 1400\n    let same = metal == \"Iron\"\n\nLogical operators:\n- && (and): true only if both sides are true\n- || (or): true if either side is true\n- ! (not): flips a Bool\n\nGrouping and precedence:\n- Use parentheses to make intent clear.\n- && runs before || if parentheses are omitted.\n\nExample:\n    let ready = (metal == \"Iron\" && temp >= 1400) || temp >= 1200",
    "manualCheck": false,
    "number": 254,
    "requires": [],
    "solution": "let ready = isIron && temperature >= minTemp\nprint(ready)",
    "starterCode": "// Challenge 254: Boolean Flags\n// Combine a Bool with a comparison.\n\nlet temperature = 1500\nlet minTemp = 1400\nlet isIron = true\n\n// TODO: Create a constant 'ready' that is true only when\n// isIron is true AND temperature >= minTemp\n// TODO: Print ready",
    "tier": "extra",
    "title": "Boolean Flags",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Booleans\n- Bool values are true or false\n- Comparisons return Bool\n- Logical operators: &&, ||, !",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use parentheses to group conditions",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "Group the strongest condition first, then add the fallback.",
      "Parentheses can clarify how the pieces should combine."
    ],
    "id": "core-extra-grouped-logic",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Booleans & Logic\nA Bool stores `true` or `false`. Comparisons produce Bool values.\n\nOverview:\n- Use comparison operators to build conditions.\n- Combine conditions with logical operators.\n\nComparison operators:\n- ==, !=, <, >, <=, >=\n    let hot = temp >= 1400\n    let same = metal == \"Iron\"\n\nLogical operators:\n- && (and): true only if both sides are true\n- || (or): true if either side is true\n- ! (not): flips a Bool\n\nGrouping and precedence:\n- Use parentheses to make intent clear.\n- && runs before || if parentheses are omitted.\n\nExample:\n    let ready = (metal == \"Iron\" && temp >= 1400) || temp >= 1200",
    "manualCheck": false,
    "number": 255,
    "requires": [],
    "solution": "let canForge = (isIron && isHot) || overrideOn\nprint(canForge)",
    "starterCode": "// Challenge 255: Grouped Logic\n// Group conditions with parentheses.\n\nlet isIron = true\nlet isHot = false\nlet overrideOn = true\n\n// TODO: Create a constant 'canForge' that is true when\n// (isIron AND isHot) OR overrideOn is true\n// TODO: Print canForge",
    "tier": "extra",
    "title": "Grouped Logic",
    "topic": "conditionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Provide a default label for a missing value",
    "expectedOutput": "Unknown",
    "fixtureFiles": [],
    "hints": [
      "Nil coalescing provides a fallback value.",
      "Store the result in a constant before printing."
    ],
    "id": "core-extra-optional-label",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nProvide a default label for a missing value\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 256,
    "requires": [],
    "solution": "let label = batchLabel ?? \"Unknown\"\nprint(label)",
    "starterCode": "// Challenge 256: Optional Label\n// Provide a default when the optional is nil.\n\nlet batchLabel: String? = nil\n\n// TODO: Use ?? to set 'label' to \"Unknown\" when batchLabel is nil\n// TODO: Print label",
    "tier": "extra",
    "title": "Optional Label",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use optional chaining with a default",
    "expectedOutput": "2",
    "fixtureFiles": [],
    "hints": [
      "temps?.count returns an optional Int.",
      "Use ?? to provide a fallback value."
    ],
    "id": "core-extra-optional-count",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nUse optional chaining with a default\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 257,
    "requires": [],
    "solution": "let count = temps?.count ?? 0\nprint(count)",
    "starterCode": "// Challenge 42.7: Optional Count\n// Use optional chaining with a default.\n\nlet temps: [Int]? = [1200, 1400]\n\n// TODO: Use optional chaining to read temps?.count\n// TODO: Use ?? to default to 0\n// TODO: Print the count",
    "tier": "extra",
    "title": "Optional Count",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Unwrap a dictionary lookup",
    "expectedOutput": "Score: 3",
    "fixtureFiles": [],
    "hints": [
      "Dictionary lookups return optionals.",
      "Use if let to unwrap the value before printing."
    ],
    "id": "core-extra-optional-dictionary-read",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nUnwrap a dictionary lookup\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 258,
    "requires": [],
    "solution": "if let score = scores[\"Iron\"] {\n    print(\"Score: \\(score)\")\n} else {\n    print(\"Missing\")\n}",
    "starterCode": "// Challenge 258: Optional Dictionary Read\n// Unwrap a dictionary lookup with if let.\n\nlet scores = [\"Iron\": 3, \"Gold\": 1]\n\n// TODO: Use if let to read the score for \"Iron\"\n// TODO: Print \"Score: <value>\" or \"Missing\"",
    "tier": "extra",
    "title": "Optional Dictionary Read",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Unwrap an optional and convert it",
    "expectedOutput": "1500",
    "fixtureFiles": [],
    "hints": [
      "You can unwrap and convert in the same if let.",
      "Provide a fallback path for invalid values."
    ],
    "id": "core-extra-optional-two-step",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nUnwrap an optional and convert it\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 259,
    "requires": [],
    "solution": "if let text = text, let value = Int(text) {\n    print(value)\n} else {\n    print(\"Invalid\")\n}",
    "starterCode": "// Challenge 259: Optional Two-Step\n// Unwrap an optional string, then convert.\n\nlet text: String? = \"1500\"\n\n// TODO: Use if let to unwrap text and convert to Int\n// TODO: Print the Int value or \"Invalid\"",
    "tier": "extra",
    "title": "Optional Two-Step",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Default a missing Bool to false",
    "expectedOutput": "false",
    "fixtureFiles": [],
    "hints": [
      "Use nil coalescing with a Bool."
    ],
    "id": "core-extra-optional-bool-default",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nDefault a missing Bool to false\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 260,
    "requires": [],
    "solution": "let ready = isReady ?? false\nprint(ready)",
    "starterCode": "// Challenge 260: Optional Bool Default\n// Default an optional Bool to false.\n\nlet isReady: Bool? = nil\n\n// TODO: Use ?? to set 'ready' to false when isReady is nil\n// TODO: Print ready",
    "tier": "extra",
    "title": "Optional Bool Default",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Optionals\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use guard let with a parameter",
    "expectedOutput": "Missing",
    "fixtureFiles": [],
    "hints": [
      "guard let unwraps and exits early when nil.",
      "Return before the success print."
    ],
    "id": "core-extra-optional-guard-name",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Optionals\nUse guard let with a parameter\n\nOverview:\n- Type? can be a value or nil\n- if let unwraps optionals safely\n- guard let unwraps with early exit\n- Optional chaining uses ?. to access values on an optional\n- ?? provides a default value\n- Int(\"123\") returns Int? (optional)\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 261,
    "requires": [],
    "solution": "func announce(name: String?) {\n    guard let name = name else {\n        print(\"Missing\")\n        return\n    }\n    print(\"Name: \\(name)\")\n}\n\nannounce(name: nil)",
    "starterCode": "// Challenge 261: Optional Guard Name\n// Use guard let for an early exit.\n\nfunc announce(name: String?) {\n    // TODO: Use guard let to unwrap name\n    // Print \"Missing\" and return if nil\n    // Otherwise print \"Name: <value>\"\n}\n\n// TODO: Call announce with nil",
    "tier": "extra",
    "title": "Optional Guard Name",
    "topic": "optionals"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Core 1 Integration\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine variables, math, and strings",
    "expectedOutput": "Heat: 1400",
    "fixtureFiles": [],
    "hints": [
      "Store the computed total in a constant before printing.",
      "Use interpolation to include the value in the output."
    ],
    "id": "core-extra-heat-summary",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Core 1 Integration\nCombine variables, math, and strings\n\nOverview:\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 262,
    "requires": [],
    "solution": "let totalHeat = baseHeat + boost\nprint(\"Heat: \\(totalHeat)\")",
    "starterCode": "// Challenge 262: Heat Summary\n// Combine variables, math, and string interpolation.\n\nlet baseHeat = 1200\nlet boost = 200\n\n// TODO: Create totalHeat by adding baseHeat and boost\n// TODO: Print \"Heat: <totalHeat>\"",
    "tier": "extra",
    "title": "Heat Summary",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Math Operators\n- +, -, *, / for arithmetic\n- % for remainder\n- Compound assignment: +=, -=, *=, /=",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Compute a Double average",
    "expectedOutput": "1400.0",
    "fixtureFiles": [],
    "hints": [
      "Convert to Double before dividing to keep the fraction.",
      "Average is (low + high) / 2."
    ],
    "id": "core-extra-average-temp",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Math Operators\nCompute a Double average\n\nOverview:\n- +, -, *, / for arithmetic\n- % for remainder\n- Compound assignment: +=, -=, *=, /=\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 263,
    "requires": [],
    "solution": "let average = (Double(low) + Double(high)) / 2\nprint(average)",
    "starterCode": "// Challenge 263: Average Temp\n// Compute a Double average.\n\nlet low = 1200\nlet high = 1600\n\n// TODO: Compute the average as a Double\n// TODO: Print the average",
    "tier": "extra",
    "title": "Average Temp",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Build a string from a number",
    "expectedOutput": "Batch-7",
    "fixtureFiles": [],
    "hints": [
      "Use interpolation to build the tag string."
    ],
    "id": "core-extra-batch-tag",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nBuild a string from a number\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 264,
    "requires": [],
    "solution": "let tag = \"Batch-\\(batchId)\"\nprint(tag)",
    "starterCode": "// Challenge 264: Batch Tag\n// Build a string from a number.\n\nlet batchId = 7\n\n// TODO: Create tag as \"Batch-<id>\"\n// TODO: Print tag",
    "tier": "extra",
    "title": "Batch Tag",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Core 1 Integration\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine math with a simple label",
    "expectedOutput": "Step 3: 600",
    "fixtureFiles": [],
    "hints": [
      "Compute the value before formatting the string.",
      "Use interpolation for both values."
    ],
    "id": "core-extra-heat-step-report",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Core 1 Integration\nCombine math with a simple label\n\nOverview:\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 265,
    "requires": [],
    "solution": "let totalHeat = step * 200\nprint(\"Step \\(step): \\(totalHeat)\")",
    "starterCode": "// Challenge 265: Heat Step Report\n// Combine math and a simple label.\n\nlet step = 3\n\n// TODO: Compute totalHeat as step * 200\n// TODO: Print \"Step <step>: <totalHeat>\"",
    "tier": "extra",
    "title": "Heat Step Report",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Return a computed value from a function",
    "expectedOutput": "1400",
    "fixtureFiles": [],
    "hints": [
      "Define a function with a return type.",
      "Call the function and print the returned value."
    ],
    "id": "core-extra-double-heat",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nReturn a computed value from a function\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 266,
    "requires": [],
    "solution": "func doubleHeat(value: Int) -> Int {\n    return value * 2\n}\n\nprint(doubleHeat(value: 700))",
    "starterCode": "// Challenge 266: Double Heat\n// Return a computed value from a function.\n\n// TODO: Create a function 'doubleHeat' that returns value * 2\n// TODO: Call doubleHeat with 700 and print the result",
    "tier": "extra",
    "title": "Double Heat",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use an external label in a function",
    "expectedOutput": "Heating to 1500",
    "fixtureFiles": [],
    "hints": [
      "Function example: heat(to value: Int).",
      "Use interpolation inside the print."
    ],
    "id": "core-extra-parameter-labels",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nUse an external label in a function\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 267,
    "requires": [],
    "solution": "func heat(to value: Int) {\n    print(\"Heating to \\(value)\")\n}\n\nheat(to: 1500)",
    "starterCode": "// Challenge 267: Parameter Labels\n// Use an external label for readability.\n\n// TODO: Create a function 'heat' that takes an Int with external label 'to'\n// TODO: Inside, print \"Heating to <value>\"\n// TODO: Call heat(to: 1500)",
    "tier": "extra",
    "title": "Parameter Labels",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Build and return a String",
    "expectedOutput": "Heat: 1200",
    "fixtureFiles": [],
    "hints": [
      "Return a String built with interpolation.",
      "Call the function inside print."
    ],
    "id": "core-extra-return-string",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nBuild and return a String\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 268,
    "requires": [],
    "solution": "func status(_ value: Int) -> String {\n    return \"Heat: \\(value)\"\n}\n\nprint(status(1200))",
    "starterCode": "// Challenge 268: Return String\n// Return a formatted String from a function.\n\n// TODO: Create a function 'status' that returns \"Heat: <value>\"\n// TODO: Print status(1200)",
    "tier": "extra",
    "title": "Return String",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Functions\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use a default parameter value",
    "expectedOutput": "Forge Iron",
    "fixtureFiles": [],
    "hints": [
      "Provide a default value in the parameter list.",
      "Call the function without passing a value."
    ],
    "id": "core-extra-parameter-default",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Functions\nUse a default parameter value\n\nOverview:\n- func name(param: Type) { ... }\n- Return with -> Type\n- Call by name with arguments\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 269,
    "requires": [],
    "solution": "func forge(material: String = \"Iron\") {\n    print(\"Forge \\(material)\")\n}\n\nforge()",
    "starterCode": "// Challenge 269: Parameter Default\n// Use a default parameter value.\n\n// TODO: Create a function 'forge' with a default material of \"Iron\"\n// TODO: Print \"Forge <material>\"\n// TODO: Call forge() with no arguments",
    "tier": "extra",
    "title": "Parameter Default",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Join words with a separator",
    "expectedOutput": "Forge-Ready",
    "fixtureFiles": [],
    "hints": [
      "Use joined(separator:)."
    ],
    "id": "core-extra-string-join",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nJoin words with a separator\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 270,
    "requires": [],
    "solution": "print(parts.joined(separator: \"-\"))",
    "starterCode": "// Challenge 270: String Join\n// Join words with a separator.\n\nlet parts = [\"Forge\", \"Ready\"]\n\n// TODO: Join parts with \"-\" and print the result",
    "tier": "extra",
    "title": "String Join",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Trim leading and trailing spaces",
    "expectedOutput": "Iron",
    "fixtureFiles": [],
    "hints": [
      "Use trimmingCharacters(in: .whitespacesAndNewlines)."
    ],
    "id": "core-extra-string-trim",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nTrim leading and trailing spaces\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 271,
    "requires": [],
    "solution": "let trimmed = raw.trimmingCharacters(in: .whitespacesAndNewlines)\nprint(trimmed)",
    "starterCode": "// Challenge 271: Trim Spaces\n// Trim whitespace from a String.\n\nimport Foundation\n\nlet raw = \"  Iron  \"\n\n// TODO: Trim whitespace and print the result",
    "tier": "extra",
    "title": "Trim Spaces",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Replace part of a String",
    "expectedOutput": "Heat: 1600",
    "fixtureFiles": [],
    "hints": [
      "Use replacingOccurrences(of:with:)."
    ],
    "id": "core-extra-string-replace",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nReplace part of a String\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 272,
    "requires": [],
    "solution": "let updated = label.replacingOccurrences(of: \"1500\", with: \"1600\")\nprint(updated)",
    "starterCode": "// Challenge 272: Replace Text\n// Replace a substring with another.\n\nlet label = \"Heat: 1500\"\n\n// TODO: Replace \"1500\" with \"1600\" and print",
    "tier": "extra",
    "title": "Replace Text",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Strings\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Split a string into lines",
    "expectedOutput": "3",
    "fixtureFiles": [],
    "hints": [
      "Split on the newline character."
    ],
    "id": "core-extra-string-lines",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Strings\nSplit a string into lines\n\nOverview:\n- count returns an Int of characters\n- lowercased()/uppercased() return new strings\n- contains(_:) returns Bool\n- hasPrefix()/hasSuffix() check prefixes/suffixes\n- split(separator:) returns [Substring]\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 273,
    "requires": [],
    "solution": "let lines = report.split(separator: \"\\n\")\nprint(lines.count)",
    "starterCode": "// Challenge 273: String Lines\n// Split a string into lines.\n\nlet report = \"Iron\\nGold\\nCopper\"\n\n// TODO: Split report into lines and print the count",
    "tier": "extra",
    "title": "String Lines",
    "topic": "strings"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Store and call a simple closure",
    "expectedOutput": "Forge",
    "fixtureFiles": [],
    "hints": [
      "Closures can be assigned to constants.",
      "Call the closure like a function."
    ],
    "id": "core-extra-closure-label",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nStore and call a simple closure\n\nOverview:\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 274,
    "requires": [],
    "solution": "let label = {\n    print(\"Forge\")\n}\n\nlabel()",
    "starterCode": "// Challenge 274: Closure Label\n// Store and call a simple closure.\n\n// TODO: Create a closure called 'label' that prints \"Forge\"\n// TODO: Call the closure",
    "tier": "extra",
    "title": "Closure Label",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Use a closure that takes a parameter",
    "expectedOutput": "1500",
    "fixtureFiles": [],
    "hints": [
      "Closures can take parameters and return values.",
      "Call the closure like a function to get the result."
    ],
    "id": "core-extra-closure-multiply",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nUse a closure that takes a parameter\n\nOverview:\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 275,
    "requires": [],
    "solution": "let tripleHeat = { (value: Int) -> Int in\n    return value * 3\n}\n\nprint(tripleHeat(500))",
    "starterCode": "// Challenge 275: Closure Multiply\n// Use a closure with a parameter.\n\n// TODO: Create a closure called 'tripleHeat' that takes an Int\n// and returns the value multiplied by 3\n// TODO: Print tripleHeat(500)",
    "tier": "extra",
    "title": "Closure Multiply",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Use trailing closure syntax",
    "expectedOutput": "20",
    "fixtureFiles": [],
    "hints": [
      "Move the closure outside the parentheses.",
      "Keep the multiplication inside the closure."
    ],
    "id": "core-extra-closure-trailing",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nUse trailing closure syntax\n\nOverview:\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 276,
    "requires": [],
    "solution": "transform(4) { value in\n    return value * 5\n}",
    "starterCode": "// Challenge 276: Closure Trailing\n// Use trailing closure syntax.\n\nfunc transform(_ value: Int, using closure: (Int) -> Int) {\n    print(closure(value))\n}\n\n// TODO: Call transform with 4 using trailing closure syntax\n// Multiply the value by 5",
    "tier": "extra",
    "title": "Closure Trailing",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Use $0 in a trailing closure",
    "expectedOutput": "10",
    "fixtureFiles": [],
    "hints": [
      "Use $0 to represent the input value."
    ],
    "id": "core-extra-closure-shorthand",
    "introduces": [
      "shorthandClosureArgs"
    ],
    "layer": "core",
    "lesson": "Lesson: Closures\nUse $0 in a trailing closure\n\nOverview:\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 277,
    "requires": [],
    "solution": "apply(8) { $0 + 2 }",
    "starterCode": "// Challenge 277: Closure Shorthand\n// Use $0 in a trailing closure.\n\nfunc apply(_ value: Int, using closure: (Int) -> Int) {\n    print(closure(value))\n}\n\n// TODO: Call apply with 8 and use $0 to add 2",
    "tier": "extra",
    "title": "Closure Shorthand",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Closures\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requireClosureUsage": true,
      "requiredTokens": []
    },
    "description": "Capture and update a value",
    "expectedOutput": "1\n2",
    "fixtureFiles": [],
    "hints": [
      "Closures can capture and mutate variables from the outer scope.",
      "Each call should increase the stored count."
    ],
    "id": "core-extra-closure-capture",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Closures\nCapture and update a value\n\nOverview:\n- Syntax: { (params) -> ReturnType in statements }\n- Types can be inferred from context\n- Single-expression closures can omit return\n- Shorthand args: $0, $1, ...\n- Trailing closure: f(x) { ... }\n- Closures capture values from outer scope\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 278,
    "requires": [],
    "solution": "func makeCounter() -> () -> Void {\n    var count = 0\n    return {\n        count += 1\n        print(count)\n    }\n}\n\nlet counter = makeCounter()\ncounter()\ncounter()",
    "starterCode": "// Challenge 278: Closure Capture\n// Capture and update a value.\n\nfunc makeCounter() -> () -> Void {\n    var count = 0\n    return {\n        // TODO: Increment count and print it\n    }\n}\n\n// TODO: Create a counter and call it twice",
    "tier": "extra",
    "title": "Closure Capture",
    "topic": "functions"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Core 1 Integration\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine math with a labeled report",
    "expectedOutput": "Shift 2: 1350",
    "fixtureFiles": [],
    "hints": [
      "Compute the total before formatting the string.",
      "Use interpolation to include both values."
    ],
    "id": "core-extra-shift-status",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Core 1 Integration\nCombine math with a labeled report\n\nOverview:\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 303,
    "requires": [],
    "solution": "let totalHeat = baseHeat + boost\nprint(\"Shift \\(shift): \\(totalHeat)\")",
    "starterCode": "// Challenge 303: Shift Status\n// Combine math with a labeled report.\n\nlet shift = 2\nlet baseHeat = 1200\nlet boost = 150\n\n// TODO: Compute totalHeat as baseHeat + boost\n// TODO: Print \"Shift 2: 1350\"",
    "tier": "extra",
    "title": "Shift Status",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Core 1 Integration\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Return a calculated value from a function",
    "expectedOutput": "Calibrated: 1280",
    "fixtureFiles": [],
    "hints": [
      "Functions that return values use -> Int.",
      "Store the returned value before printing."
    ],
    "id": "core-extra-calibration-report",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Core 1 Integration\nReturn a calculated value from a function\n\nOverview:\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 304,
    "requires": [],
    "solution": "func calibrate(base: Int, offset: Int) -> Int {\n    return base + offset\n}\n\nlet result = calibrate(base: 1200, offset: 80)\nprint(\"Calibrated: \\(result)\")",
    "starterCode": "// Challenge 304: Calibration Report\n// Return a calculated value from a function.\n\n// TODO: Create a function 'calibrate' that returns base + offset\n// TODO: Call calibrate with 1200 and 80\n// TODO: Print \"Calibrated: 1280\"",
    "tier": "extra",
    "title": "Calibration Report",
    "topic": "general"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Core 1 Integration\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Update a value in place and report it",
    "expectedOutput": "Heat now: 1250",
    "fixtureFiles": [],
    "hints": [
      "Compound assignment updates the variable directly.",
      "Use interpolation in the output."
    ],
    "id": "core-extra-heat-adjustment",
    "introduces": [],
    "layer": "core",
    "lesson": "Lesson: Core 1 Integration\nUpdate a value in place and report it\n\nOverview:\n- Use let for constants; var for values that change\n- Compound assignment: +=, -=, *=, /=\n- Comparisons produce Bool: ==, !=, <, >, <=, >=\n- Logic: && (and), || (or), ! (not)\n- Functions: func name(param: Type) -> ReturnType { ... }\n- Interpolation: \"Value: \\(value)\"\n\nPractice:\n- Implement the TODOs.\n- Press Enter to run the check.\n- Use `h` for hints and `c` for cheatsheet when stuck.",
    "manualCheck": false,
    "number": 305,
    "requires": [],
    "solution": "heat += 250\nprint(\"Heat now: \\(heat)\")",
    "starterCode": "// Challenge 305: Heat Adjustment\n// Update a value in place and report it.\n\nvar heat = 1000\n\n// TODO: Increase heat by 250 using +=\n// TODO: Print \"Heat now: 1250\"",
    "tier": "extra",
    "title": "Heat Adjustment",
    "topic": "general"
  }
]
