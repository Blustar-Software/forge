[
  {
    "canonicalId": "",
    "cheatsheet": "SwiftPM\n- Package.swift defines targets and dependencies\n- Executable targets produce CLI tools\n- Library targets expose modules",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Identify modules and dependencies",
    "expectedOutput": "Dependencies: none",
    "fixtureFiles": [],
    "hints": [
      "Package.swift lists dependencies near the top.",
      "Summarize the dependency situation in one line."
    ],
    "id": "",
    "introduces": [
      "swiftpmDependencies"
    ],
    "layer": "crust",
    "lesson": "Lesson: SwiftPM\nSwift Package Manager defines how modules build and depend on each other.\n\nOverview:\n- `Package.swift` declares products, targets, and dependencies.\n- Targets control source layout and resource inclusion.\n- Build configs and flags tune behavior by environment.\n\nExample:\n- Add a library dependency and link it in a target.\n- Keep package boundaries small and purposeful.\n\nGuidelines:\n- Favor simple package graphs.\n- Keep public APIs stable across package boundaries.",
    "manualCheck": false,
    "number": 208,
    "requires": [],
    "solution": "print(\"Dependencies: none\")",
    "starterCode": "// Challenge 208: Dependencies & Imports\n// Expected output: Dependencies: none\n\n// TODO: Print \"Dependencies: none\"",
    "tier": "mainline",
    "title": "Dependencies & Imports",
    "topic": "swiftpm"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Performance\n- Arrays use copy-on-write behavior\n- MemoryLayout reports size/stride/alignment\n- Measure before optimizing",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Print the active build configuration",
    "expectedOutput": "Release",
    "fixtureFiles": [],
    "hints": [
      "#if DEBUG is true in debug builds.",
      "Scripts run without DEBUG, so the release branch should print."
    ],
    "id": "",
    "introduces": [
      "buildConfigs"
    ],
    "layer": "crust",
    "lesson": "Lesson: SwiftPM\nSwift Package Manager defines how modules build and depend on each other.\n\nOverview:\n- `Package.swift` declares products, targets, and dependencies.\n- Targets control source layout and resource inclusion.\n- Build configs and flags tune behavior by environment.\n\nExample:\n- Add a library dependency and link it in a target.\n- Keep package boundaries small and purposeful.\n\nGuidelines:\n- Favor simple package graphs.\n- Keep public APIs stable across package boundaries.",
    "manualCheck": false,
    "number": 209,
    "requires": [],
    "solution": "#if DEBUG\nprint(\"Debug\")\n#else\nprint(\"Release\")\n#endif",
    "starterCode": "// Challenge 209: Build Configs & Flags\n// Print the active build configuration.\n// Note: Running with `swift` uses release-style flags, so DEBUG is not set.\n\n// TODO: Use #if DEBUG to print \"Debug\", otherwise \"Release\"",
    "tier": "mainline",
    "title": "Build Configs & Flags",
    "topic": "swiftpm"
  },
  {
    "canonicalId": "",
    "cheatsheet": "SwiftPM\n- Package.swift defines targets and dependencies\n- Executable targets produce CLI tools\n- Library targets expose modules",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Plan a SwiftPM feature module",
    "expectedOutput": "Module: AnalyticsKit",
    "fixtureFiles": [],
    "hints": [
      "Pick a small feature you could isolate into a module.",
      "Use the provided module name."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: SwiftPM\nSwift Package Manager defines how modules build and depend on each other.\n\nOverview:\n- `Package.swift` declares products, targets, and dependencies.\n- Targets control source layout and resource inclusion.\n- Build configs and flags tune behavior by environment.\n\nExample:\n- Add a library dependency and link it in a target.\n- Keep package boundaries small and purposeful.\n\nGuidelines:\n- Favor simple package graphs.\n- Keep public APIs stable across package boundaries.",
    "manualCheck": false,
    "number": 210,
    "requires": [
      "swiftpmBasics",
      "swiftpmDependencies",
      "buildConfigs"
    ],
    "solution": "print(\"Module: AnalyticsKit\")",
    "starterCode": "// Challenge 210: Integration Challenge\n// Prereqs: SwiftPM basics, dependencies, build configs.\n//\n// Expected output: Module: AnalyticsKit\n\n// TODO: Print \"Module: AnalyticsKit\"",
    "tier": "mainline",
    "title": "Integration Challenge",
    "topic": "swiftpm"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Macros (Usage)\n- Macros are expanded at compile time\n- Macro packages are added via SwiftPM\n- Use #macroName(...) per macro definition",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Review how macro authoring works",
    "expectedOutput": "Macro author: provides expansion code",
    "fixtureFiles": [],
    "hints": [
      "Macro authors write code that generates code at compile time.",
      "Provide a concise summary of the authoring role."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Macros\nMacros generate Swift code at compile time.\n\nOverview:\n- Use macros to remove repetitive boilerplate.\n- Prefer small, predictable expansions.\n- Keep generated behavior obvious to readers.\n\nExample:\n- Attached macros can add members or conformances.\n- Freestanding macros can transform expressions/declarations.\n\nGuidelines:\n- Validate generated output during development.\n- Avoid macros when a simple function solves the problem.",
    "manualCheck": false,
    "number": 211,
    "requires": [],
    "solution": "print(\"Macro author: provides expansion code\")",
    "starterCode": "// Challenge 211: Macro Authoring (Concepts)\n// Expected output: Macro author: provides expansion code\n\n// TODO: Print \"Macro author: provides expansion code\"",
    "tier": "mainline",
    "title": "Macro Authoring (Concepts)",
    "topic": "macros"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Inspect values with Mirror",
    "expectedOutput": "metal\nheat",
    "fixtureFiles": [],
    "hints": [
      "Mirror.children yields label/value pairs.",
      "Print the label for each child."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 212,
    "requires": [],
    "solution": "struct ForgeLog {\n    let metal: String\n    let heat: Int\n}\n\nlet log = ForgeLog(metal: \"Iron\", heat: 1200)\nlet mirror = Mirror(reflecting: log)\n\nfor child in mirror.children {\n    if let label = child.label {\n        print(label)\n    }\n}",
    "starterCode": "// Challenge 212: Reflection\n// Inspect values with Mirror.\n\nstruct ForgeLog {\n    let metal: String\n    let heat: Int\n}\n\nlet log = ForgeLog(metal: \"Iron\", heat: 1200)\nlet mirror = Mirror(reflecting: log)\n\n// TODO: Print each child label on its own line",
    "tier": "mainline",
    "title": "Reflection",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Generics\n- some returns an opaque type\n- any uses an existential type\n- Type erasure hides concrete types\n- where clauses add constraints",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Understand protocol witness tables",
    "expectedOutput": "Witness tables map protocol implementations",
    "fixtureFiles": [],
    "hints": [
      "Witness tables map protocol requirements to implementations.",
      "Provide a one-line summary of the concept."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Generics\nAdvanced generics express relationships between types.\n\nOverview:\n- Associated types describe placeholder types in protocols.\n- `where` clauses constrain combinations of generic types.\n- Protocol extensions can add constrained default behavior.\n\nExample:\n    protocol Store {\n        associatedtype Item\n        mutating func add(_ item: Item)\n    }\n\nGuidelines:\n- Encode real constraints in the type system.\n- Prefer simpler signatures unless constraints add clear value.",
    "manualCheck": false,
    "number": 213,
    "requires": [],
    "solution": "print(\"Witness tables map protocol implementations\")",
    "starterCode": "// Challenge 213: Witness Tables (Concepts)\n// Expected output: Witness tables map protocol implementations\n\n// TODO: Print \"Witness tables map protocol implementations\"",
    "tier": "mainline",
    "title": "Witness Tables (Concepts)",
    "topic": "generics"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Sketch a simple ViewModel",
    "expectedOutput": "Status: Ready",
    "fixtureFiles": [],
    "hints": [
      "ViewModels map model data into display-ready values.",
      "Return a string based on the model's heat."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 214,
    "requires": [],
    "solution": "struct FurnaceModel {\n    let heat: Int\n}\n\nstruct FurnaceViewModel {\n    let model: FurnaceModel\n    var status: String {\n        return model.heat >= 1200 ? \"Ready\" : \"Cold\"\n    }\n}\n\nlet viewModel = FurnaceViewModel(model: FurnaceModel(heat: 1300))\nprint(\"Status: \\(viewModel.status)\")",
    "starterCode": "// Challenge 214: MVVM vs MVC\n// Sketch a simple ViewModel.\n\nstruct FurnaceModel {\n    let heat: Int\n}\n\nstruct FurnaceViewModel {\n    let model: FurnaceModel\n    // TODO: Add a computed property status returning \"Ready\" when heat >= 1200\n}\n\nlet viewModel = FurnaceViewModel(model: FurnaceModel(heat: 1300))\nprint(\"Status: \\(viewModel.status)\")",
    "tier": "mainline",
    "title": "MVVM vs MVC",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Inject a dependency via protocol",
    "expectedOutput": "Forge started",
    "fixtureFiles": [],
    "hints": [
      "Inject the logger through the initializer or property.",
      "Use logger.log inside start()."
    ],
    "id": "",
    "introduces": [
      "dependencyInjection"
    ],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 215,
    "requires": [],
    "solution": "protocol Logger {\n    func log(_ message: String)\n}\n\nstruct ConsoleLogger: Logger {\n    func log(_ message: String) {\n        print(message)\n    }\n}\n\nstruct ForgeService {\n    let logger: any Logger\n    func start() {\n        logger.log(\"Forge started\")\n    }\n}\n\nlet service = ForgeService(logger: ConsoleLogger())\nservice.start()",
    "starterCode": "// Challenge 215: Dependency Injection\n// Inject a dependency via protocol.\n\nprotocol Logger {\n    func log(_ message: String)\n}\n\nstruct ConsoleLogger: Logger {\n    func log(_ message: String) {\n        print(message)\n    }\n}\n\nstruct ForgeService {\n    let logger: any Logger\n    // TODO: Add a start() method that logs \"Forge started\"\n}\n\nlet service = ForgeService(logger: ConsoleLogger())\n// TODO: Call service.start()",
    "tier": "mainline",
    "title": "Dependency Injection",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Centralize navigation flow",
    "expectedOutput": "Start",
    "fixtureFiles": [],
    "hints": [
      "Coordinators expose a start() method.",
      "Print a simple marker string."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 216,
    "requires": [],
    "solution": "protocol Coordinator {\n    func start()\n}\n\nstruct AppCoordinator: Coordinator {\n    func start() {\n        print(\"Start\")\n    }\n}\n\nlet coordinator = AppCoordinator()\ncoordinator.start()",
    "starterCode": "// Challenge 216: Coordinator Pattern\n// Centralize navigation flow.\n\nprotocol Coordinator {\n    func start()\n}\n\nstruct AppCoordinator: Coordinator {\n    // TODO: Implement start() to print \"Start\"\n}\n\nlet coordinator = AppCoordinator()\ncoordinator.start()",
    "tier": "mainline",
    "title": "Coordinator Pattern",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Separate data access from logic",
    "expectedOutput": "Count: 2",
    "fixtureFiles": [],
    "hints": [
      "Call repository.loadItems inside count().",
      "Return the count of the items array."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 217,
    "requires": [],
    "solution": "protocol InventoryRepository {\n    func loadItems() -> [String]\n}\n\nstruct MemoryInventoryRepository: InventoryRepository {\n    let items: [String]\n    func loadItems() -> [String] { items }\n}\n\nstruct InventoryService {\n    let repository: any InventoryRepository\n    func count() -> Int {\n        return repository.loadItems().count\n    }\n}\n\nlet service = InventoryService(repository: MemoryInventoryRepository(items: [\"Iron\", \"Gold\"]))\nprint(\"Count: \\(service.count())\")",
    "starterCode": "// Challenge 217: Repository Pattern\n// Separate data access from logic.\n\nprotocol InventoryRepository {\n    func loadItems() -> [String]\n}\n\nstruct MemoryInventoryRepository: InventoryRepository {\n    let items: [String]\n    func loadItems() -> [String] { items }\n}\n\nstruct InventoryService {\n    let repository: any InventoryRepository\n    // TODO: Add count() -> Int that returns item count\n}\n\nlet service = InventoryService(repository: MemoryInventoryRepository(items: [\"Iron\", \"Gold\"]))\nprint(\"Count: \\(service.count())\")",
    "tier": "mainline",
    "title": "Repository Pattern",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Swap in a mock for testing",
    "expectedOutput": "Now: 5",
    "fixtureFiles": [],
    "hints": [
      "Mocks return a fixed value for predictable output.",
      "Call clock.now() inside report()."
    ],
    "id": "",
    "introduces": [
      "protocolMocking"
    ],
    "layer": "crust",
    "lesson": "Lesson: Protocol Design\nProtocol design defines stable contracts between components.\n\nOverview:\n- Keep each protocol focused on one responsibility.\n- Use associated types when relationships are important.\n- Add default behavior in constrained extensions when it helps.\n\nExample:\n- Define small service protocols for dependency injection.\n- Provide test doubles that conform to the same protocol.\n\nGuidelines:\n- Avoid giant umbrella protocols.\n- Model behavior, not concrete storage.",
    "manualCheck": false,
    "number": 218,
    "requires": [],
    "solution": "protocol Clock {\n    func now() -> Int\n}\n\nstruct MockClock: Clock {\n    let value: Int\n    func now() -> Int { value }\n}\n\nfunc report(_ clock: any Clock) {\n    print(\"Now: \\(clock.now())\")\n}\n\nreport(MockClock(value: 5))",
    "starterCode": "// Challenge 218: Protocol Mocking\n// Swap in a mock for testing.\n\nprotocol Clock {\n    func now() -> Int\n}\n\nstruct MockClock: Clock {\n    let value: Int\n    func now() -> Int { value }\n}\n\nfunc report(_ clock: any Clock) {\n    // TODO: Print \"Now: <value>\"\n}\n\nreport(MockClock(value: 5))",
    "tier": "mainline",
    "title": "Protocol Mocking",
    "topic": "protocols"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Recall red/green/refactor",
    "expectedOutput": "TDD: Red, Green, Refactor",
    "fixtureFiles": [],
    "hints": [
      "Red: failing test; Green: make it pass; Refactor: clean up.",
      "Output the phase names in order."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Testing\nTests protect behavior and support refactoring.\n\nOverview:\n- Unit tests validate isolated functions and types.\n- Integration tests verify command flows and file interactions.\n- Use deterministic inputs and explicit assertions.\n\nExample:\n- Arrange input, act by calling the function, assert exact output.\n- Prefer clear failure messages over broad checks.\n\nGuidelines:\n- Test critical paths and edge cases.\n- Keep tests fast and independent.",
    "manualCheck": false,
    "number": 219,
    "requires": [],
    "solution": "print(\"TDD: Red, Green, Refactor\")",
    "starterCode": "// Challenge 219: TDD Cycle (Concepts)\n// Expected output: TDD: Red, Green, Refactor\n\n// TODO: Print \"TDD: Red, Green, Refactor\"",
    "tier": "mainline",
    "title": "TDD Cycle (Concepts)",
    "topic": "testing"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Macros (Usage)\n- Macros are expanded at compile time\n- Macro packages are added via SwiftPM\n- Use #macroName(...) per macro definition",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Review async XCTest patterns",
    "expectedOutput": "Async tests can await in XCTest",
    "fixtureFiles": [],
    "hints": [
      "XCTest supports async test methods with async/await.",
      "Summarize the async testing capability in one line."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Testing\nTests protect behavior and support refactoring.\n\nOverview:\n- Unit tests validate isolated functions and types.\n- Integration tests verify command flows and file interactions.\n- Use deterministic inputs and explicit assertions.\n\nExample:\n- Arrange input, act by calling the function, assert exact output.\n- Prefer clear failure messages over broad checks.\n\nGuidelines:\n- Test critical paths and edge cases.\n- Keep tests fast and independent.",
    "manualCheck": false,
    "number": 220,
    "requires": [],
    "solution": "print(\"Async tests can await in XCTest\")",
    "starterCode": "// Challenge 220: Async Testing (Concepts)\n// Expected output: Async tests can await in XCTest\n\n// TODO: Print \"Async tests can await in XCTest\"",
    "tier": "mainline",
    "title": "Async Testing (Concepts)",
    "topic": "testing"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Recall UI testing focus",
    "expectedOutput": "UI tests verify user flows",
    "fixtureFiles": [],
    "hints": [
      "UI tests simulate user flows and verify visible outcomes.",
      "Summarize the UI testing focus in one line."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Testing\nTests protect behavior and support refactoring.\n\nOverview:\n- Unit tests validate isolated functions and types.\n- Integration tests verify command flows and file interactions.\n- Use deterministic inputs and explicit assertions.\n\nExample:\n- Arrange input, act by calling the function, assert exact output.\n- Prefer clear failure messages over broad checks.\n\nGuidelines:\n- Test critical paths and edge cases.\n- Keep tests fast and independent.",
    "manualCheck": false,
    "number": 221,
    "requires": [],
    "solution": "print(\"UI tests verify user flows\")",
    "starterCode": "// Challenge 221: UI Testing (Concepts)\n// Expected output: UI tests verify user flows\n\n// TODO: Print \"UI tests verify user flows\"",
    "tier": "mainline",
    "title": "UI Testing (Concepts)",
    "topic": "testing"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Performance\n- Arrays use copy-on-write behavior\n- MemoryLayout reports size/stride/alignment\n- Measure before optimizing",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Access memory with an unsafe pointer",
    "expectedOutput": "42",
    "fixtureFiles": [],
    "hints": [
      "withUnsafePointer passes a pointer to a closure.",
      "Use pointer.pointee to read the value."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Memory\nMemory behavior affects performance and correctness in larger systems.\n\nOverview:\n- Understand value vs reference semantics.\n- Watch ARC churn in high-frequency paths.\n- Avoid retain cycles in closure-heavy code.\n\nExample:\n- Capture `[weak self]` in escaping closures tied to object lifetime.\n- Prefer value types for independent snapshots.\n\nGuidelines:\n- Measure before micro-optimizing.\n- Choose ownership rules that are explicit and simple.",
    "manualCheck": false,
    "number": 222,
    "requires": [],
    "solution": "var value = 42\n\nwithUnsafePointer(to: &value) { pointer in\n    print(pointer.pointee)\n}",
    "starterCode": "// Challenge 222: Unsafe Pointers\n// Access memory with an unsafe pointer.\n\nvar value = 42\n\n// TODO: Use withUnsafePointer(to:) to print the value",
    "tier": "mainline",
    "title": "Unsafe Pointers",
    "topic": "memory"
  },
  {
    "canonicalId": "",
    "cheatsheet": "SwiftPM\n- Package.swift defines targets and dependencies\n- Executable targets produce CLI tools\n- Library targets expose modules",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Recall how C interop works",
    "expectedOutput": "C interop uses module maps",
    "fixtureFiles": [],
    "hints": [
      "Swift can import C APIs via module maps or bridging headers.",
      "Summarize how C interop is wired."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Interop\nInterop bridges Swift code with external systems and formats.\n\nOverview:\n- Convert between representations carefully.\n- Validate boundaries and error paths.\n- Keep adapters thin and well-tested.\n\nExample:\n- Map raw input into typed Swift models.\n- Surface conversion failures with structured errors.\n\nGuidelines:\n- Isolate boundary code from core logic.\n- Preserve invariants when crossing module/language edges.",
    "manualCheck": false,
    "number": 223,
    "requires": [],
    "solution": "print(\"C interop uses module maps\")",
    "starterCode": "// Challenge 223: C Interop (Concepts)\n// Expected output: C interop uses module maps\n\n// TODO: Print \"C interop uses module maps\"",
    "tier": "mainline",
    "title": "C Interop (Concepts)",
    "topic": "interop"
  },
  {
    "canonicalId": "",
    "cheatsheet": "SwiftPM\n- Package.swift defines targets and dependencies\n- Executable targets produce CLI tools\n- Library targets expose modules",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Recall Obj-C bridging basics",
    "expectedOutput": "@objc and bridging headers",
    "fixtureFiles": [],
    "hints": [
      "@objc exposes Swift to Obj-C; bridging headers import Obj-C to Swift.",
      "Summarize the interop mechanism in one line."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Interop\nInterop bridges Swift code with external systems and formats.\n\nOverview:\n- Convert between representations carefully.\n- Validate boundaries and error paths.\n- Keep adapters thin and well-tested.\n\nExample:\n- Map raw input into typed Swift models.\n- Surface conversion failures with structured errors.\n\nGuidelines:\n- Isolate boundary code from core logic.\n- Preserve invariants when crossing module/language edges.",
    "manualCheck": false,
    "number": 224,
    "requires": [],
    "solution": "print(\"@objc and bridging headers\")",
    "starterCode": "// Challenge 224: Objective-C Interop (Concepts)\n// Expected output: @objc and bridging headers\n\n// TODO: Print \"@objc and bridging headers\"",
    "tier": "mainline",
    "title": "Objective-C Interop (Concepts)",
    "topic": "interop"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Recall common debugger commands",
    "expectedOutput": "LLDB: po, bt",
    "fixtureFiles": [],
    "hints": [
      "Examples: breakpoint set, po, bt.",
      "Provide a short list of common commands."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 225,
    "requires": [],
    "solution": "print(\"LLDB: po, bt\")",
    "starterCode": "// Challenge 225: LLDB Tactics (Concepts)\n// Expected output: LLDB: po, bt\n\n// TODO: Print \"LLDB: po, bt\"",
    "tier": "mainline",
    "title": "LLDB Tactics (Concepts)",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Errors\n- Define: enum MyError: Error { case ... }\n- Throwing functions use throws\n- Call with try\n- Handle with do { try ... } catch { ... }\n- try? returns Optional, nil on error",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Surface errors with context",
    "expectedOutput": "Error: overheating",
    "fixtureFiles": [],
    "hints": [
      "The catch block handles thrown errors.",
      "Print a clear message for the failure case."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Error Handling Patterns\nAdvanced error handling balances clarity with recovery.\n\nOverview:\n- Prefer typed errors with actionable cases.\n- Convert low-level failures into domain errors near boundaries.\n- Preserve context when rethrowing or wrapping.\n\nExample:\n- Catch parsing failures, then throw a domain-specific error case.\n- Use `Result` when explicit success/failure values simplify flow.\n\nGuidelines:\n- Do not silence important errors.\n- Keep failure messages specific and testable.",
    "manualCheck": false,
    "number": 226,
    "requires": [
      "doCatch",
      "throwKeyword",
      "tryKeyword"
    ],
    "solution": "enum ForgeError: Error {\n    case overheated\n}\n\nfunc checkHeat(_ value: Int) throws {\n    if value > 2000 {\n        throw ForgeError.overheated\n    }\n}\n\n do {\n    try checkHeat(2200)\n    print(\"OK\")\n} catch {\n    print(\"Error: overheating\")\n}",
    "starterCode": "// Challenge 226: Diagnostics\n// Surface errors with context.\n\nenum ForgeError: Error {\n    case overheated\n}\n\nfunc checkHeat(_ value: Int) throws {\n    if value > 2000 {\n        throw ForgeError.overheated\n    }\n}\n\ndo {\n    try checkHeat(2200)\n    print(\"OK\")\n} catch {\n    // TODO: Print \"Error: overheating\"\n}",
    "tier": "mainline",
    "title": "Diagnostics",
    "topic": "errors"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Recall basic Git workflow steps",
    "expectedOutput": "Git: branch, commit, push, PR",
    "fixtureFiles": [],
    "hints": [
      "Example: branch -> commit -> push -> PR.",
      "Summarize the workflow sequence."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 227,
    "requires": [],
    "solution": "print(\"Git: branch, commit, push, PR\")",
    "starterCode": "// Challenge 227: Git Workflows (Concepts)\n// Expected output: Git: branch, commit, push, PR\n\n// TODO: Print \"Git: branch, commit, push, PR\"",
    "tier": "mainline",
    "title": "Git Workflows (Concepts)",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Generics\n- some returns an opaque type\n- any uses an existential type\n- Type erasure hides concrete types\n- where clauses add constraints",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Combine DI and protocol testing",
    "expectedOutput": "Sum: 6",
    "fixtureFiles": [],
    "hints": [
      "Call source.values() and sum the results.",
      "Return the total from sum()."
    ],
    "id": "",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Protocol Design\nProtocol design defines stable contracts between components.\n\nOverview:\n- Keep each protocol focused on one responsibility.\n- Use associated types when relationships are important.\n- Add default behavior in constrained extensions when it helps.\n\nExample:\n- Define small service protocols for dependency injection.\n- Provide test doubles that conform to the same protocol.\n\nGuidelines:\n- Avoid giant umbrella protocols.\n- Model behavior, not concrete storage.",
    "manualCheck": false,
    "number": 228,
    "requires": [
      "protocols",
      "dependencyInjection",
      "protocolMocking",
      "reduce"
    ],
    "solution": "protocol DataSource {\n    func values() -> [Int]\n}\n\nstruct MemorySource: DataSource {\n    let items: [Int]\n    func values() -> [Int] { items }\n}\n\nstruct Analyzer {\n    let source: DataSource\n    func sum() -> Int {\n        return source.values().reduce(0, +)\n    }\n}\n\nlet analyzer = Analyzer(source: MemorySource(items: [1, 2, 3]))\nprint(\"Sum: \\(analyzer.sum())\")",
    "starterCode": "// Challenge 228: Integration Challenge\n// Combine DI and protocol testing.\n// Prereqs: protocols, dependency injection, protocol mocking.\n\nprotocol DataSource {\n    func values() -> [Int]\n}\n\nstruct MemorySource: DataSource {\n    let items: [Int]\n    func values() -> [Int] { items }\n}\n\nstruct Analyzer {\n    let source: DataSource\n    // TODO: Add sum() -> Int that totals the source values\n}\n\nlet analyzer = Analyzer(source: MemorySource(items: [1, 2, 3]))\nprint(\"Sum: \\(analyzer.sum())\")",
    "tier": "mainline",
    "title": "Integration Challenge",
    "topic": "protocols"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Concurrency\n- async functions can suspend and resume\n- await calls async work and returns the value\n- Task runs async work concurrently\n- withTaskGroup manages child tasks",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Pause an async task before printing",
    "expectedOutput": "Done",
    "fixtureFiles": [],
    "hints": [
      "Task.sleep is async and can be called with try? await.",
      "Print after the sleep call."
    ],
    "id": "crust-extra-async-sleep",
    "introduces": [
      "taskSleep"
    ],
    "layer": "crust",
    "lesson": "Lesson: Concurrency\nStructured concurrency runs async work clearly and safely.\n\nOverview:\n- Mark async functions with `async` and call with `await`.\n- Use `Task` for concurrent units of work.\n- Use `withTaskGroup` for dynamic fan-out.\n\nExample:\n    func load() async -> Int { 5 }\n    let value = await load()\n\nGuidelines:\n- Keep async boundaries explicit.\n- Preserve deterministic output order when required.",
    "manualCheck": false,
    "number": 229,
    "requires": [],
    "solution": "import Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nrunAsync {\n    try? await Task.sleep(nanoseconds: 50_000_000)\n    print(\"Done\")\n}",
    "starterCode": "// Challenge 229: Async Sleep\n// Pause an async task before printing.\n\nimport Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nrunAsync {\n    // TODO: Sleep briefly with Task.sleep\n    // TODO: Print \"Done\"\n}",
    "tier": "extra",
    "title": "Async Sleep",
    "topic": "concurrency"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Actors\n- actor isolates mutable state\n- actor methods are accessed with await\n- @MainActor marks main-thread-bound work",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Update actor state safely",
    "expectedOutput": "Balance: 7",
    "fixtureFiles": [],
    "hints": [
      "Actor methods are called with await.",
      "Print the balance after both updates."
    ],
    "id": "crust-extra-actor-balance",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Actors\nActors protect mutable state from data races.\n\nOverview:\n- Actor methods are isolated by default.\n- Access actor state with `await` from outside.\n- Use actors for shared mutable state across tasks.\n\nExample:\n    actor Counter {\n        private var value = 0\n        func inc() { value += 1 }\n        func read() -> Int { value }\n    }\n\nGuidelines:\n- Keep actor APIs small.\n- Avoid unnecessary cross-actor hops in tight loops.",
    "manualCheck": false,
    "number": 230,
    "requires": [],
    "solution": "import Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nactor Ledger {\n    private var balance = 0\n\n    func add(_ value: Int) {\n        balance += value\n    }\n\n    func current() -> Int {\n        return balance\n    }\n}\n\nlet ledger = Ledger()\nrunAsync {\n    await ledger.add(3)\n    await ledger.add(4)\n    let value = await ledger.current()\n    print(\"Balance: \\(value)\")\n}",
    "starterCode": "// Challenge 230: Actor Balance\n// Update actor state safely.\n\nimport Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nactor Ledger {\n    private var balance = 0\n    // TODO: Add add(_:) and current() methods\n}\n\nlet ledger = Ledger()\nrunAsync {\n    // TODO: Add 3 and 4, then print \"Balance: 7\"\n}",
    "tier": "extra",
    "title": "Actor Balance",
    "topic": "actors"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Concurrency\n- async functions can suspend and resume\n- await calls async work and returns the value\n- Task runs async work concurrently\n- withTaskGroup manages child tasks",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Move values across tasks safely",
    "expectedOutput": "Count: 3",
    "fixtureFiles": [],
    "hints": [
      "Sendable marks the struct as safe for concurrency.",
      "Use values.count in the output."
    ],
    "id": "crust-extra-sendable-snapshot",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Concurrency\nStructured concurrency runs async work clearly and safely.\n\nOverview:\n- Mark async functions with `async` and call with `await`.\n- Use `Task` for concurrent units of work.\n- Use `withTaskGroup` for dynamic fan-out.\n\nExample:\n    func load() async -> Int { 5 }\n    let value = await load()\n\nGuidelines:\n- Keep async boundaries explicit.\n- Preserve deterministic output order when required.",
    "manualCheck": false,
    "number": 231,
    "requires": [],
    "solution": "struct Snapshot: Sendable {\n    let values: [Int]\n}\n\nlet snapshot = Snapshot(values: [1, 2, 3])\nprint(\"Count: \\(snapshot.values.count)\")",
    "starterCode": "// Challenge 231: Sendable Snapshot\n// Move values across tasks safely.\n\nstruct Snapshot: Sendable {\n    let values: [Int]\n}\n\nlet snapshot = Snapshot(values: [1, 2, 3])\n// TODO: Print \"Count: 3\"",
    "tier": "extra",
    "title": "Sendable Snapshot",
    "topic": "concurrency"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Key Paths\n- Syntax: \\Type.property\n- Access with value[keyPath: path]\n- Map with \\Type.property",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Compute an average using key paths",
    "expectedOutput": "Average: 80",
    "fixtureFiles": [],
    "hints": [
      "Use ores.map(\\.purity) to extract values.",
      "Average is sum / count with Int math."
    ],
    "id": "crust-extra-keypath-average",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Key Paths\nKey paths reference properties as values.\n\nOverview:\n- `\\Type.property` captures a readable path.\n- Use key paths with APIs like `map` and sorting helpers.\n- Writable key paths enable generic mutation utilities.\n\nExample:\n    struct Reading { let temp: Int }\n    let temps = readings.map(\\.temp)\n\nGuidelines:\n- Prefer key paths when extracting one property repeatedly.\n- Keep transformations readable and explicit.",
    "manualCheck": false,
    "number": 232,
    "requires": [],
    "solution": "struct Ore {\n    let name: String\n    let purity: Int\n}\n\nlet ores = [\n    Ore(name: \"Iron\", purity: 70),\n    Ore(name: \"Gold\", purity: 90),\n]\n\nlet values = ores.map(\\.purity)\nlet average = values.reduce(0, +) / values.count\nprint(\"Average: \\(average)\")",
    "starterCode": "// Challenge 232: KeyPath Average\n// Compute an average using key paths.\n\nstruct Ore {\n    let name: String\n    let purity: Int\n}\n\nlet ores = [\n    Ore(name: \"Iron\", purity: 70),\n    Ore(name: \"Gold\", purity: 90),\n]\n\n// TODO: Map purity values with a key path\n// TODO: Print \"Average: 80\"",
    "tier": "extra",
    "title": "KeyPath Average",
    "topic": "keyPaths"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Sequences\n- Sequence can be iterated once with for-in\n- Collection adds indices and count\n- lazy creates deferred transformations",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Filter and sum with lazy",
    "expectedOutput": "Total: 120",
    "fixtureFiles": [],
    "hints": [
      "Use lazy.filter then lazy.map before reducing.",
      "Sum the transformed values to match the total."
    ],
    "id": "crust-extra-lazy-even-sum",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Sequences\nSequences model one-pass element production.\n\nOverview:\n- Many standard transforms (`map`, `filter`, `reduce`) are sequence-based.\n- `lazy` delays work until values are consumed.\n- Choose Array when you need storage; Sequence when you need iteration.\n\nExample:\n    let total = values.lazy\n        .filter { $0 > 0 }\n        .map { $0 * 2 }\n        .reduce(0, +)\n\nGuidelines:\n- Use lazy pipelines for large data chains.\n- Materialize to Array only when needed.",
    "manualCheck": false,
    "number": 233,
    "requires": [],
    "solution": "let numbers = [1, 2, 3, 4, 5, 6]\n\nlet total = numbers.lazy\n    .filter { $0 % 2 == 0 }\n    .map { $0 * 10 }\n    .reduce(0, +)\n\nprint(\"Total: \\(total)\")",
    "starterCode": "// Challenge 233: Lazy Even Sum\n// Filter and sum with lazy.\n\nlet numbers = [1, 2, 3, 4, 5, 6]\n\n// TODO: Use lazy to keep even numbers\n// TODO: Multiply each by 10\n// TODO: Print \"Total: 120\"",
    "tier": "extra",
    "title": "Lazy Even Sum",
    "topic": "sequences"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Generics\n- some returns an opaque type\n- any uses an existential type\n- Type erasure hides concrete types\n- where clauses add constraints",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Compare values with generics",
    "expectedOutput": "9",
    "fixtureFiles": [],
    "hints": [
      "Return a if a > b, otherwise b.",
      "Use a generic constraint on Comparable."
    ],
    "id": "crust-extra-generic-max",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Generics\nAdvanced generics express relationships between types.\n\nOverview:\n- Associated types describe placeholder types in protocols.\n- `where` clauses constrain combinations of generic types.\n- Protocol extensions can add constrained default behavior.\n\nExample:\n    protocol Store {\n        associatedtype Item\n        mutating func add(_ item: Item)\n    }\n\nGuidelines:\n- Encode real constraints in the type system.\n- Prefer simpler signatures unless constraints add clear value.",
    "manualCheck": false,
    "number": 234,
    "requires": [],
    "solution": "func maxValue<T: Comparable>(_ a: T, _ b: T) -> T {\n    return a > b ? a : b\n}\n\nprint(maxValue(4, 9))",
    "starterCode": "// Challenge 234: Generic Max\n// Compare values with generics.\n\n// TODO: Write maxValue<T: Comparable>(_:_:) -> T\n// TODO: Print maxValue(4, 9)",
    "tier": "extra",
    "title": "Generic Max",
    "topic": "generics"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Generics\n- some returns an opaque type\n- any uses an existential type\n- Type erasure hides concrete types\n- where clauses add constraints",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Erase sequence types",
    "expectedOutput": "Count: 3",
    "fixtureFiles": [],
    "hints": [
      "Wrap the array with AnySequence(...).",
      "Materialize the sequence to count it."
    ],
    "id": "crust-extra-anysequence",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Sequences\nSequences model one-pass element production.\n\nOverview:\n- Many standard transforms (`map`, `filter`, `reduce`) are sequence-based.\n- `lazy` delays work until values are consumed.\n- Choose Array when you need storage; Sequence when you need iteration.\n\nExample:\n    let total = values.lazy\n        .filter { $0 > 0 }\n        .map { $0 * 2 }\n        .reduce(0, +)\n\nGuidelines:\n- Use lazy pipelines for large data chains.\n- Materialize to Array only when needed.",
    "manualCheck": false,
    "number": 235,
    "requires": [],
    "solution": "func makeSequence() -> AnySequence<Int> {\n    return AnySequence([1, 2, 3])\n}\n\nlet sequence = makeSequence()\nlet items = Array(sequence)\nprint(\"Count: \\(items.count)\")",
    "starterCode": "// Challenge 235: AnySequence\n// Erase sequence types.\n\nfunc makeSequence() -> AnySequence<Int> {\n    // TODO: Return AnySequence with [1, 2, 3]\n}\n\nlet sequence = makeSequence()\nlet items = Array(sequence)\nprint(\"Count: \\(items.count)\")",
    "tier": "extra",
    "title": "AnySequence",
    "topic": "sequences"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Provide default values",
    "expectedOutput": "Limit: 5\nMissing: 0",
    "fixtureFiles": [],
    "hints": [
      "Return values[member, default: 0].",
      "The missing key should return 0."
    ],
    "id": "crust-extra-dynamicmemberlookup-extra",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 236,
    "requires": [],
    "solution": "@dynamicMemberLookup\nstruct Defaults {\n    var values: [String: Int]\n    subscript(dynamicMember member: String) -> Int {\n        return values[member, default: 0]\n    }\n}\n\nlet defaults = Defaults(values: [\"limit\": 5])\nprint(\"Limit: \\(defaults.limit)\")\nprint(\"Missing: \\(defaults.missing)\")",
    "starterCode": "// Challenge 236: dynamicMemberLookup Extra\n// Provide default values.\n\n@dynamicMemberLookup\nstruct Defaults {\n    var values: [String: Int]\n    // TODO: Add dynamicMember subscript returning Int\n}\n\nlet defaults = Defaults(values: [\"limit\": 5])\nprint(\"Limit: \\(defaults.limit)\")\nprint(\"Missing: \\(defaults.missing)\")",
    "tier": "extra",
    "title": "dynamicMemberLookup Extra",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Sum keyword arguments",
    "expectedOutput": "6",
    "fixtureFiles": [],
    "hints": [
      "Keyword arguments arrive as KeyValuePairs.",
      "Sum the values and return the total."
    ],
    "id": "crust-extra-dynamiccallable-keywords",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Features\nAdvanced Swift features improve expressiveness when used deliberately.\n\nOverview:\n- Compose protocols, generics, and builders for clear APIs.\n- Keep abstractions small and testable.\n- Favor explicit data flow over clever indirection.\n\nExample:\n- Build a mini DSL with result builders.\n- Layer protocol-driven components with dependency injection.\n\nGuidelines:\n- Introduce abstraction only when it reduces duplication.\n- Prefer clarity over novelty.",
    "manualCheck": false,
    "number": 237,
    "requires": [],
    "solution": "@dynamicCallable\nstruct KeyedAdder {\n    func dynamicallyCall(withKeywordArguments args: KeyValuePairs<String, Int>) -> Int {\n        return args.reduce(0) { $0 + $1.value }\n    }\n}\n\nlet adder = KeyedAdder()\nprint(adder(a: 1, b: 2, c: 3))",
    "starterCode": "// Challenge 237: dynamicCallable Keywords\n// Sum keyword arguments.\n\n@dynamicCallable\nstruct KeyedAdder {\n    // TODO: Implement dynamicallyCall(withKeywordArguments:)\n}\n\nlet adder = KeyedAdder()\nprint(adder(a: 1, b: 2, c: 3))",
    "tier": "extra",
    "title": "dynamicCallable Keywords",
    "topic": "advancedFeatures"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Performance\n- Arrays use copy-on-write behavior\n- MemoryLayout reports size/stride/alignment\n- Measure before optimizing",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Inspect stride and alignment",
    "expectedOutput": "Stride: 2\nAlignment: 2",
    "fixtureFiles": [],
    "hints": [
      "Use MemoryLayout<UInt16>.stride and .alignment.",
      "Format the output to include both labels."
    ],
    "id": "crust-extra-memorylayout-stride",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Memory\nMemory behavior affects performance and correctness in larger systems.\n\nOverview:\n- Understand value vs reference semantics.\n- Watch ARC churn in high-frequency paths.\n- Avoid retain cycles in closure-heavy code.\n\nExample:\n- Capture `[weak self]` in escaping closures tied to object lifetime.\n- Prefer value types for independent snapshots.\n\nGuidelines:\n- Measure before micro-optimizing.\n- Choose ownership rules that are explicit and simple.",
    "manualCheck": false,
    "number": 238,
    "requires": [],
    "solution": "print(\"Stride: \\(MemoryLayout<UInt16>.stride)\")\nprint(\"Alignment: \\(MemoryLayout<UInt16>.alignment)\")",
    "starterCode": "// Challenge 238: MemoryLayout Stride\n// Inspect stride and alignment.\n\n// TODO: Print \"Stride: 2\" and \"Alignment: 2\" for UInt16",
    "tier": "extra",
    "title": "MemoryLayout Stride",
    "topic": "memory"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Performance\n- Arrays use copy-on-write behavior\n- MemoryLayout reports size/stride/alignment\n- Measure before optimizing",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Update through a pointer",
    "expectedOutput": "10",
    "fixtureFiles": [],
    "hints": [
      "Use pointer.pointee to update the value.",
      "Print after the pointer scope."
    ],
    "id": "crust-extra-unsafe-mutation",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Memory\nMemory behavior affects performance and correctness in larger systems.\n\nOverview:\n- Understand value vs reference semantics.\n- Watch ARC churn in high-frequency paths.\n- Avoid retain cycles in closure-heavy code.\n\nExample:\n- Capture `[weak self]` in escaping closures tied to object lifetime.\n- Prefer value types for independent snapshots.\n\nGuidelines:\n- Measure before micro-optimizing.\n- Choose ownership rules that are explicit and simple.",
    "manualCheck": false,
    "number": 239,
    "requires": [],
    "solution": "var value = 5\n\nwithUnsafeMutablePointer(to: &value) { pointer in\n    pointer.pointee += 5\n}\n\nprint(value)",
    "starterCode": "// Challenge 239: Unsafe Mutation\n// Update through a pointer.\n\nvar value = 5\n\n// TODO: Use withUnsafeMutablePointer to add 5\n// TODO: Print value (should be 10)",
    "tier": "extra",
    "title": "Unsafe Mutation",
    "topic": "memory"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Generics\n- some returns an opaque type\n- any uses an existential type\n- Type erasure hides concrete types\n- where clauses add constraints",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use a constrained extension",
    "expectedOutput": "true",
    "fixtureFiles": [],
    "hints": [
      "Add a constrained extension for Int.",
      "Use value % 2 == 0."
    ],
    "id": "crust-extra-where-filter",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Advanced Generics\nAdvanced generics express relationships between types.\n\nOverview:\n- Associated types describe placeholder types in protocols.\n- `where` clauses constrain combinations of generic types.\n- Protocol extensions can add constrained default behavior.\n\nExample:\n    protocol Store {\n        associatedtype Item\n        mutating func add(_ item: Item)\n    }\n\nGuidelines:\n- Encode real constraints in the type system.\n- Prefer simpler signatures unless constraints add clear value.",
    "manualCheck": false,
    "number": 240,
    "requires": [],
    "solution": "struct Box<T> {\n    let value: T\n}\n\nextension Box where T == Int {\n    func isEven() -> Bool {\n        return value % 2 == 0\n    }\n}\n\nlet box = Box(value: 6)\nprint(box.isEven())",
    "starterCode": "// Challenge 240: Where Filter\n// Use a constrained extension.\n\nstruct Box<T> {\n    let value: T\n}\n\nextension Box where T == Int {\n    // TODO: Add isEven() -> Bool\n}\n\nlet box = Box(value: 6)\nprint(box.isEven())",
    "tier": "extra",
    "title": "Where Filter",
    "topic": "generics"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Concurrency\n- async functions can suspend and resume\n- await calls async work and returns the value\n- Task runs async work concurrently\n- withTaskGroup manages child tasks",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Run async calls in parallel",
    "expectedOutput": "Sum: 5",
    "fixtureFiles": [],
    "hints": [
      "Use async let to start both calls.",
      "Await both values before summing."
    ],
    "id": "crust-extra-async-let",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Concurrency\nStructured concurrency runs async work clearly and safely.\n\nOverview:\n- Mark async functions with `async` and call with `await`.\n- Use `Task` for concurrent units of work.\n- Use `withTaskGroup` for dynamic fan-out.\n\nExample:\n    func load() async -> Int { 5 }\n    let value = await load()\n\nGuidelines:\n- Keep async boundaries explicit.\n- Preserve deterministic output order when required.",
    "manualCheck": false,
    "number": 252,
    "requires": [],
    "solution": "import Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nfunc fetchA() async -> Int {\n    return 2\n}\n\nfunc fetchB() async -> Int {\n    return 3\n}\n\nrunAsync {\n    async let a = fetchA()\n    async let b = fetchB()\n    let sum = await a + b\n    print(\"Sum: \\(sum)\")\n}",
    "starterCode": "// Challenge 252: Async Let\n// Run async calls in parallel.\n\nimport Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nfunc fetchA() async -> Int {\n    return 2\n}\n\nfunc fetchB() async -> Int {\n    return 3\n}\n\nrunAsync {\n    // TODO: Use async let for fetchA and fetchB\n    // TODO: Print \"Sum: 5\"\n}",
    "tier": "extra",
    "title": "Async Let",
    "topic": "concurrency"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Write a minimal XCTest case (simulated)",
    "expectedOutput": "XCTest ready",
    "fixtureFiles": [],
    "hints": [
      "Subclass XCTestCase for tests.",
      "Use XCTAssertEqual inside testSum()."
    ],
    "id": "crust-extra-xctest-micro",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Testing\nTests protect behavior and support refactoring.\n\nOverview:\n- Unit tests validate isolated functions and types.\n- Integration tests verify command flows and file interactions.\n- Use deterministic inputs and explicit assertions.\n\nExample:\n- Arrange input, act by calling the function, assert exact output.\n- Prefer clear failure messages over broad checks.\n\nGuidelines:\n- Test critical paths and edge cases.\n- Keep tests fast and independent.",
    "manualCheck": false,
    "number": 253,
    "requires": [],
    "solution": "class XCTestCase {}\nfunc XCTAssertEqual<T: Equatable>(_ lhs: T, _ rhs: T) {}\n\nclass SampleTests: XCTestCase {\n    func testSum() {\n        XCTAssertEqual(2 + 2, 4)\n    }\n}\n\nprint(\"XCTest ready\")",
    "starterCode": "// Challenge 253: XCTest Micro Example\n// Forge includes a tiny XCTest stub so this compiles as a script.\n// Expected output: XCTest ready\n\nclass XCTestCase {}\nfunc XCTAssertEqual<T: Equatable>(_ lhs: T, _ rhs: T) {}\n\n// TODO: Create class SampleTests: XCTestCase\n// TODO: Add func testSum() with XCTAssertEqual(2 + 2, 4)\n\n// TODO: Print \"XCTest ready\"",
    "tier": "extra",
    "title": "XCTest Micro Example",
    "topic": "testing"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Concurrency\n- async functions can suspend and resume\n- await calls async work and returns the value\n- Task runs async work concurrently\n- withTaskGroup manages child tasks",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Await a simple async value",
    "expectedOutput": "Heat: 1500",
    "fixtureFiles": [],
    "hints": [
      "Use await to get the async value."
    ],
    "id": "crust-extra-async-warmup",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Concurrency\nStructured concurrency runs async work clearly and safely.\n\nOverview:\n- Mark async functions with `async` and call with `await`.\n- Use `Task` for concurrent units of work.\n- Use `withTaskGroup` for dynamic fan-out.\n\nExample:\n    func load() async -> Int { 5 }\n    let value = await load()\n\nGuidelines:\n- Keep async boundaries explicit.\n- Preserve deterministic output order when required.",
    "manualCheck": false,
    "number": 292,
    "requires": [],
    "solution": "import Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nfunc heat() async -> Int {\n    return 1500\n}\n\nrunAsync {\n    let value = await heat()\n    print(\"Heat: \\(value)\")\n}",
    "starterCode": "// Challenge 292: Async Warmup\n// Await a simple async value.\n\nimport Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nfunc heat() async -> Int {\n    return 1500\n}\n\nrunAsync {\n    // TODO: Await heat() and print \"Heat: 1500\"\n}",
    "tier": "extra",
    "title": "Async Warmup",
    "topic": "concurrency"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Concurrency\n- async functions can suspend and resume\n- await calls async work and returns the value\n- Task runs async work concurrently\n- withTaskGroup manages child tasks",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Use an actor for state",
    "expectedOutput": "1 2",
    "fixtureFiles": [],
    "hints": [
      "Call actor methods with await."
    ],
    "id": "crust-extra-actor-counter",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Actors\nActors protect mutable state from data races.\n\nOverview:\n- Actor methods are isolated by default.\n- Access actor state with `await` from outside.\n- Use actors for shared mutable state across tasks.\n\nExample:\n    actor Counter {\n        private var value = 0\n        func inc() { value += 1 }\n        func read() -> Int { value }\n    }\n\nGuidelines:\n- Keep actor APIs small.\n- Avoid unnecessary cross-actor hops in tight loops.",
    "manualCheck": false,
    "number": 293,
    "requires": [],
    "solution": "import Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nactor Counter {\n    var value = 0\n    func increment() -> Int {\n        value += 1\n        return value\n    }\n}\n\nrunAsync {\n    let counter = Counter()\n    let first = await counter.increment()\n    let second = await counter.increment()\n    print(\"\\(first) \\(second)\")\n}",
    "starterCode": "// Challenge 293: Actor Counter\n// Use an actor for state.\n\nimport Foundation\n\nfunc runAsync(_ operation: @escaping () async -> Void) {\n    let group = DispatchGroup()\n    group.enter()\n    Task {\n        await operation()\n        group.leave()\n    }\n    group.wait()\n}\n\nactor Counter {\n    var value = 0\n    func increment() -> Int {\n        value += 1\n        return value\n    }\n}\n\nrunAsync {\n    // TODO: Create a Counter, call increment twice, and print \"1 2\"\n}",
    "tier": "extra",
    "title": "Actor Counter",
    "topic": "actors"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Properties\n- Stored properties hold values\n- Computed properties use get/set\n- willSet/didSet observe changes\n- lazy defers initialization\n- static creates type-level members",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Clamp a value with a wrapper",
    "expectedOutput": "100",
    "fixtureFiles": [],
    "hints": [
      "The wrapper clamps values between 0 and 100."
    ],
    "id": "crust-extra-property-wrapper",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Property Wrappers\nProperty wrappers package repeated property behavior.\n\nOverview:\n- Define wrapper with `@propertyWrapper`.\n- Expose wrapped value via `wrappedValue`.\n- Optionally expose extra API via `projectedValue`.\n\nExample:\n    @propertyWrapper\n    struct Clamped {\n        private var value: Int\n        var wrappedValue: Int {\n            get { value }\n            set { value = max(0, min(100, newValue)) }\n        }\n        init(wrappedValue: Int) { value = wrappedValue }\n    }\n\nGuidelines:\n- Use wrappers for cross-cutting rules.\n- Keep wrapper behavior unsurprising.",
    "manualCheck": false,
    "number": 294,
    "requires": [],
    "solution": "@propertyWrapper\nstruct Clamped {\n    private var value: Int\n    init(wrappedValue: Int) {\n        value = min(max(0, wrappedValue), 100)\n    }\n    var wrappedValue: Int {\n        get { value }\n        set { value = min(max(0, newValue), 100) }\n    }\n}\n\nstruct Gauge {\n    @Clamped var pressure: Int\n}\n\nvar gauge = Gauge(pressure: 120)\nprint(gauge.pressure)",
    "starterCode": "// Challenge 294: Property Wrapper\n// Clamp a value with a wrapper.\n\n@propertyWrapper\nstruct Clamped {\n    private var value: Int\n    init(wrappedValue: Int) {\n        value = min(max(0, wrappedValue), 100)\n    }\n    var wrappedValue: Int {\n        get { value }\n        set { value = min(max(0, newValue), 100) }\n    }\n}\n\nstruct Gauge {\n    @Clamped var pressure: Int\n}\n\nvar gauge = Gauge(pressure: 120)\n// TODO: Print gauge.pressure",
    "tier": "extra",
    "title": "Property Wrapper",
    "topic": "propertyWrappers"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Key Paths\n- Syntax: \\Type.property\n- Access with value[keyPath: path]\n- Map with \\Type.property",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Sort using a key path",
    "expectedOutput": "Gold, Iron, Copper",
    "fixtureFiles": [],
    "hints": [
      "Use sorted with a closure reading \\Alloy.purity.",
      "Map to names and join with a separator."
    ],
    "id": "crust-extra-keypath-sort",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Key Paths\nKey paths reference properties as values.\n\nOverview:\n- `\\Type.property` captures a readable path.\n- Use key paths with APIs like `map` and sorting helpers.\n- Writable key paths enable generic mutation utilities.\n\nExample:\n    struct Reading { let temp: Int }\n    let temps = readings.map(\\.temp)\n\nGuidelines:\n- Prefer key paths when extracting one property repeatedly.\n- Keep transformations readable and explicit.",
    "manualCheck": false,
    "number": 295,
    "requires": [],
    "solution": "let sorted = items.sorted { $0[keyPath: \\Alloy.purity] > $1[keyPath: \\Alloy.purity] }\nlet names = sorted.map { $0.name }.joined(separator: \", \")\nprint(names)",
    "starterCode": "// Challenge 295: Key Path Sort\n// Sort using a key path.\n\nstruct Alloy {\n    let name: String\n    let purity: Int\n}\n\nlet items = [\n    Alloy(name: \"Iron\", purity: 80),\n    Alloy(name: \"Gold\", purity: 95),\n    Alloy(name: \"Copper\", purity: 60)\n]\n\n// TODO: Sort by purity descending using a key path\n// TODO: Print the names joined by \", \"",
    "tier": "extra",
    "title": "Key Path Sort",
    "topic": "keyPaths"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Protocols\n- Define required properties and methods\n- Types conform by implementing requirements\n- Protocols can be used as types",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Return an opaque protocol type",
    "expectedOutput": "1500",
    "fixtureFiles": [],
    "hints": [
      "Use 'some' for an opaque return type."
    ],
    "id": "crust-extra-opaque-return",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Protocol Design\nProtocol design defines stable contracts between components.\n\nOverview:\n- Keep each protocol focused on one responsibility.\n- Use associated types when relationships are important.\n- Add default behavior in constrained extensions when it helps.\n\nExample:\n- Define small service protocols for dependency injection.\n- Provide test doubles that conform to the same protocol.\n\nGuidelines:\n- Avoid giant umbrella protocols.\n- Model behavior, not concrete storage.",
    "manualCheck": false,
    "number": 296,
    "requires": [],
    "solution": "func makeSource() -> some HeatSource {\n    return Burner(heat: 1500)\n}\n\nprint(makeSource().heat)",
    "starterCode": "// Challenge 296: Opaque Return\n// Return an opaque protocol type.\n\nprotocol HeatSource {\n    var heat: Int { get }\n}\n\nstruct Burner: HeatSource {\n    let heat: Int\n}\n\n// TODO: Create makeSource() -> some HeatSource\n// TODO: Print makeSource().heat",
    "tier": "extra",
    "title": "Opaque Return",
    "topic": "protocols"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Collection Transforms\n- map transforms each element into a new array\n- filter keeps elements matching a condition\n- reduce combines elements into one value\n- compactMap removes nils and unwraps values\n- flatMap flattens nested arrays\n- min()/max() return Optional values",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Use lazy chains",
    "expectedOutput": "[15, 16]",
    "fixtureFiles": [],
    "hints": [
      "Use lazy.filter and lazy.map, then Array(...) to materialize."
    ],
    "id": "crust-extra-lazy-sequence",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Sequences\nSequences model one-pass element production.\n\nOverview:\n- Many standard transforms (`map`, `filter`, `reduce`) are sequence-based.\n- `lazy` delays work until values are consumed.\n- Choose Array when you need storage; Sequence when you need iteration.\n\nExample:\n    let total = values.lazy\n        .filter { $0 > 0 }\n        .map { $0 * 2 }\n        .reduce(0, +)\n\nGuidelines:\n- Use lazy pipelines for large data chains.\n- Materialize to Array only when needed.",
    "manualCheck": false,
    "number": 297,
    "requires": [],
    "solution": "let result = Array(temps.lazy.filter { $0 >= 1500 }.map { $0 / 100 })\nprint(result)",
    "starterCode": "// Challenge 297: Lazy Sequence\n// Use lazy chains to transform data.\n\nlet temps = [1200, 1500, 1600]\n\n// TODO: Use lazy to filter temps >= 1500 and map to /100\n// TODO: Print the resulting array",
    "tier": "extra",
    "title": "Lazy Sequence",
    "topic": "sequences"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Reason about macro expansion (simulated)",
    "expectedOutput": "2 + 2 = 4",
    "fixtureFiles": [],
    "hints": [
      "Just print the expected expansion result."
    ],
    "id": "crust-extra-macro-sample",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Macros\nMacros generate Swift code at compile time.\n\nOverview:\n- Use macros to remove repetitive boilerplate.\n- Prefer small, predictable expansions.\n- Keep generated behavior obvious to readers.\n\nExample:\n- Attached macros can add members or conformances.\n- Freestanding macros can transform expressions/declarations.\n\nGuidelines:\n- Validate generated output during development.\n- Avoid macros when a simple function solves the problem.",
    "manualCheck": false,
    "number": 298,
    "requires": [],
    "solution": "print(\"2 + 2 = 4\")",
    "starterCode": "// Challenge 298: Macro Sample\n// Simulate macro output for understanding.\n\n// Assume a macro expands: #stringify(2 + 2) -> (\"2 + 2\", 4)\n// TODO: Print \"2 + 2 = 4\"",
    "tier": "extra",
    "title": "Macro Sample",
    "topic": "macros"
  },
  {
    "canonicalId": "",
    "cheatsheet": "SwiftPM\n- Package.swift defines targets and dependencies\n- Executable targets produce CLI tools\n- Library targets expose modules",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Identify targets in a package (simulated)",
    "expectedOutput": "Targets: forge, forgeTests",
    "fixtureFiles": [],
    "hints": [
      "This is a simulated check of package structure."
    ],
    "id": "crust-extra-swiftpm-targets",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: SwiftPM\nSwift Package Manager defines how modules build and depend on each other.\n\nOverview:\n- `Package.swift` declares products, targets, and dependencies.\n- Targets control source layout and resource inclusion.\n- Build configs and flags tune behavior by environment.\n\nExample:\n- Add a library dependency and link it in a target.\n- Keep package boundaries small and purposeful.\n\nGuidelines:\n- Favor simple package graphs.\n- Keep public APIs stable across package boundaries.",
    "manualCheck": false,
    "number": 299,
    "requires": [],
    "solution": "print(\"Targets: forge, forgeTests\")",
    "starterCode": "// Challenge 299: SwiftPM Targets\n// Simulate SwiftPM target awareness.\n\n// TODO: Print \"Targets: forge, forgeTests\"",
    "tier": "extra",
    "title": "SwiftPM Targets",
    "topic": "swiftpm"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Performance\n- Arrays use copy-on-write behavior\n- MemoryLayout reports size/stride/alignment\n- Measure before optimizing",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Measure elapsed time (simulated)",
    "expectedOutput": "Elapsed: 0.25",
    "fixtureFiles": [],
    "hints": [
      "Use end.timeIntervalSince(start) for the elapsed seconds."
    ],
    "id": "crust-extra-performance-timing",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Performance\nOptimize with measurement first, then targeted changes.\n\nOverview:\n- Reduce repeated allocations and unnecessary copies.\n- Avoid repeated work inside loops.\n- Prefer linear passes over nested scans when possible.\n\nExample:\n- Cache derived values when reused.\n- Use `Set` for frequent membership checks.\n\nGuidelines:\n- Keep code correct first.\n- Verify gains with realistic inputs.",
    "manualCheck": false,
    "number": 300,
    "requires": [],
    "solution": "import Foundation\n\nlet start = Date()\nlet end = start.addingTimeInterval(0.25)\nprint(\"Elapsed: \\(end.timeIntervalSince(start))\")",
    "starterCode": "// Challenge 300: Performance Timing\n// Simulate a timing measurement.\n\nimport Foundation\n\nlet start = Date()\nlet end = start.addingTimeInterval(0.25)\n\n// TODO: Print \"Elapsed: 0.25\"",
    "tier": "extra",
    "title": "Performance Timing",
    "topic": "performance"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Use Foundation bridging types",
    "expectedOutput": "5",
    "fixtureFiles": [],
    "hints": [
      "NSString length counts characters."
    ],
    "id": "crust-extra-interop-bridge",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Interop\nInterop bridges Swift code with external systems and formats.\n\nOverview:\n- Convert between representations carefully.\n- Validate boundaries and error paths.\n- Keep adapters thin and well-tested.\n\nExample:\n- Map raw input into typed Swift models.\n- Surface conversion failures with structured errors.\n\nGuidelines:\n- Isolate boundary code from core logic.\n- Preserve invariants when crossing module/language edges.",
    "manualCheck": false,
    "number": 301,
    "requires": [],
    "solution": "import Foundation\n\nlet name = \"Forge\"\nlet nsName = name as NSString\nprint(nsName.length)",
    "starterCode": "// Challenge 301: Interop Bridge\n// Use Foundation bridging types.\n\nimport Foundation\n\nlet name = \"Forge\"\nlet nsName = name as NSString\n\n// TODO: Print nsName.length",
    "tier": "extra",
    "title": "Interop Bridge",
    "topic": "interop"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Advanced Features\n- Custom operators declare precedence\n- Subscripts can accept multiple parameters\n- dynamicMemberLookup forwards unknown members\n- dynamicCallable forwards calls",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Simulate a tiny test assertion",
    "expectedOutput": "Pass",
    "fixtureFiles": [],
    "hints": [
      "Call the helper with the computed value."
    ],
    "id": "crust-extra-test-assert",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Testing\nTests protect behavior and support refactoring.\n\nOverview:\n- Unit tests validate isolated functions and types.\n- Integration tests verify command flows and file interactions.\n- Use deterministic inputs and explicit assertions.\n\nExample:\n- Arrange input, act by calling the function, assert exact output.\n- Prefer clear failure messages over broad checks.\n\nGuidelines:\n- Test critical paths and edge cases.\n- Keep tests fast and independent.",
    "manualCheck": false,
    "number": 302,
    "requires": [],
    "solution": "assertEqual(3 + 2, 5)",
    "starterCode": "// Challenge 302: Test Assert\n// Simulate a tiny test assertion.\n\nfunc assertEqual(_ lhs: Int, _ rhs: Int) {\n    if lhs == rhs {\n        print(\"Pass\")\n    } else {\n        print(\"Fail\")\n    }\n}\n\n// TODO: Call assertEqual(3 + 2, 5)",
    "tier": "extra",
    "title": "Test Assert",
    "topic": "testing"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Errors\n- Define: enum MyError: Error { case ... }\n- Throwing functions use throws\n- Call with try\n- Handle with do { try ... } catch { ... }\n- try? returns Optional, nil on error",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Attach context to a thrown error",
    "expectedOutput": "Too low: 900",
    "fixtureFiles": [],
    "hints": [
      "Throw the error with the value as context.",
      "Use a specific catch to extract the value."
    ],
    "id": "crust-extra-error-context",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Error Handling Patterns\nAdvanced error handling balances clarity with recovery.\n\nOverview:\n- Prefer typed errors with actionable cases.\n- Convert low-level failures into domain errors near boundaries.\n- Preserve context when rethrowing or wrapping.\n\nExample:\n- Catch parsing failures, then throw a domain-specific error case.\n- Use `Result` when explicit success/failure values simplify flow.\n\nGuidelines:\n- Do not silence important errors.\n- Keep failure messages specific and testable.",
    "manualCheck": false,
    "number": 306,
    "requires": [],
    "solution": "enum HeatError: Error {\n    case tooLow(Int)\n}\n\nfunc checkHeat(_ value: Int) throws {\n    if value < 1000 {\n        throw HeatError.tooLow(value)\n    }\n}\n\ndo {\n    try checkHeat(900)\n} catch HeatError.tooLow(let value) {\n    print(\"Too low: \\(value)\")\n}",
    "starterCode": "// Challenge 306: Error Context\n// Attach context to a thrown error.\n\nenum HeatError: Error {\n    case tooLow(Int)\n}\n\nfunc checkHeat(_ value: Int) throws {\n    // TODO: Throw tooLow(value) when value < 1000\n}\n\ndo {\n    try checkHeat(900)\n} catch HeatError.tooLow(let value) {\n    // TODO: Print \"Too low: 900\"\n}",
    "tier": "extra",
    "title": "Error Context",
    "topic": "errors"
  },
  {
    "canonicalId": "",
    "cheatsheet": "Performance\n- Arrays use copy-on-write behavior\n- MemoryLayout reports size/stride/alignment\n- Measure before optimizing",
    "constraintProfile": {
      "allowConcurrency": false,
      "allowFileIO": false,
      "allowNetwork": false,
      "allowedImports": [],
      "disallowedTokens": [
        "import"
      ],
      "requiredTokens": []
    },
    "description": "Compare loop costs deterministically",
    "expectedOutput": "Total: 15\nSteps: 5",
    "fixtureFiles": [],
    "hints": [
      "Track both the total and number of iterations.",
      "Print the totals on separate lines."
    ],
    "id": "crust-extra-performance-loop",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Performance\nOptimize with measurement first, then targeted changes.\n\nOverview:\n- Reduce repeated allocations and unnecessary copies.\n- Avoid repeated work inside loops.\n- Prefer linear passes over nested scans when possible.\n\nExample:\n- Cache derived values when reused.\n- Use `Set` for frequent membership checks.\n\nGuidelines:\n- Keep code correct first.\n- Verify gains with realistic inputs.",
    "manualCheck": false,
    "number": 307,
    "requires": [],
    "solution": "var total = 0\nvar steps = 0\n\nfor value in 1...5 {\n    total += value\n    steps += 1\n}\n\nprint(\"Total: \\(total)\")\nprint(\"Steps: \\(steps)\")",
    "starterCode": "// Challenge 307: Performance Loop\n// Compare loop costs deterministically.\n//\n// Expected output:\n// Total: 15\n// Steps: 5\n\nvar total = 0\nvar steps = 0\n\n// TODO: Loop from 1 to 5\n// TODO: Add each value to total and increment steps\n// TODO: Print total and steps",
    "tier": "extra",
    "title": "Performance Loop",
    "topic": "performance"
  },
  {
    "canonicalId": "",
    "cheatsheet": "SwiftPM\n- Package.swift defines targets and dependencies\n- Executable targets produce CLI tools\n- Library targets expose modules",
    "constraintProfile": {
      "allowConcurrency": true,
      "allowFileIO": true,
      "allowNetwork": false,
      "allowedImports": [
        "Foundation"
      ],
      "disallowedTokens": [],
      "requiredTokens": []
    },
    "description": "Bridge Swift to NSString",
    "expectedOutput": "5",
    "fixtureFiles": [],
    "hints": [
      "Use NSString(name) or name as NSString.",
      "Print the length property."
    ],
    "id": "crust-extra-objc-bridge",
    "introduces": [],
    "layer": "crust",
    "lesson": "Lesson: Interop\nInterop bridges Swift code with external systems and formats.\n\nOverview:\n- Convert between representations carefully.\n- Validate boundaries and error paths.\n- Keep adapters thin and well-tested.\n\nExample:\n- Map raw input into typed Swift models.\n- Surface conversion failures with structured errors.\n\nGuidelines:\n- Isolate boundary code from core logic.\n- Preserve invariants when crossing module/language edges.",
    "manualCheck": false,
    "number": 308,
    "requires": [],
    "solution": "import Foundation\n\nlet name = \"Forge\"\nlet nsName = name as NSString\nprint(nsName.length)",
    "starterCode": "// Challenge 308: Objective-C Bridge\n// Bridge Swift to NSString.\n\nimport Foundation\n\nlet name = \"Forge\"\n// TODO: Convert name to NSString and print its length",
    "tier": "extra",
    "title": "Objective-C Bridge",
    "topic": "interop"
  }
]
