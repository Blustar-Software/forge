

# Operational Guide: Hybrid Use of Phi-4 Mini and Phi-4 Mini Reasoning

## 1. Model Roles

| Model | Primary Role | Use Case Examples |
|-------|--------------|-----------------|
| **Mini** | Deterministic, format-compliant output | JSON/YAML generation, API-ready structured data, exact prompt execution |
| **Mini Reasoning** | Logical analysis and multi-step problem solving | Planning, debugging, abstract reasoning, candidate solution exploration |

---

## 2. Recommended Workflow

### Reasoning Phase (Mini Reasoning)
- Tasks:
  - Step-by-step logic
  - Deduction or inference
  - Multi-step reasoning challenges
- Output can be verbose; focus on accuracy over format compliance.

### Compliance Phase (Mini)
- Tasks:
  - Convert outputs from Reasoning Phase into strict, structured outputs
  - Enforce formatting rules (JSON, CSV, YAML)
  - Validate against schemas or output constraints

**Example Flow:**

```
[Prompt Reasoning Task] → Mini Reasoning → Analyze step-by-step solution
↓
[Generate structured output] → Mini → JSON/YAML compliant
```

---

## 3. Task Classification

| Task Type | Recommended Model | Notes |
|-----------|-----------------|-------|
| Structured data output | Mini | Ensures exact compliance with schemas |
| Logical puzzles / abstract reasoning | Mini Reasoning | Focus on correctness and multi-step logic |
| Testing / validation | Both | Reasoning explores possibilities; Mini enforces format |
| Exploratory analysis | Mini Reasoning | Candidate solutions, multi-step decomposition |
| Production pipelines | Mini | Deterministic, API-safe output |

---

## 4. Best Practices

- **Separate reasoning from formatting**: Never rely on Reasoning model for strict output in pipelines.
- **Use Mini for validation**: Ensure machine-readability even if Reasoning output is correct.
- **Optional iterative loop**: Feed selected Reasoning output to Mini for structured output generation.
- **Limit verbose output in pipelines**: Apply truncation or summarization when using Reasoning in production.

---

## 5. Summary

This guide establishes a hybrid workflow:

1. **Mini Reasoning**: Handles abstract, multi-step, and logical reasoning tasks.
2. **Mini**: Produces format-compliant, deterministic outputs suitable for structured pipelines.

The approach balances reasoning capability with output reliability, making it safe for both exploratory analysis and production-ready data generation.

---

## 6. Forge CLI Runbook (Current Implementation, February 12, 2026)

This runbook describes the current command path implemented in Forge for experimental AI-assisted challenge authoring.

### 6.1 Intended Usage

- Maintainer-only pipeline for generating and promoting curriculum candidates.
- Not part of learner runtime flow.
- Promotion is gated with verification and automatic rollback on downstream failures.

### 6.2 Canonical Command Sequence

Generate artifacts:

```sh
swift run forge ai-generate --dry-run
```

Optional live generation via Phi:

```sh
export FORGE_AI_PHI_ENDPOINT="https://<endpoint>"
export FORGE_AI_PHI_API_KEY="<key>"
export FORGE_AI_PHI_MODEL="Phi-4-mini-instruct" # optional
swift run forge ai-generate --live
```

Verify candidate:

```sh
swift run forge ai-verify
```

Promote candidate:

```sh
swift run forge ai-promote --target Sources/forge/Curriculum/core3_challenges.json
```

### 6.3 Artifact Contract

Default artifact directory:

`workspace_verify/ai_candidates/`

Expected files:

- `request.json`
- `candidate.json`
- `report.json`

### 6.4 Promotion Gates and Guardrails

`ai-promote` enforces all of the following:

1. `report.json` must parse and have an allowed status:
   - `scaffold`
   - `dry_run_scaffold`
   - `live_success`
   - `live_fallback_scaffold`
2. `report.json.candidatePath` must match the provided candidate path.
3. Full `ai-verify` must pass.
4. Candidate is appended to target curriculum JSON.
5. Post-append checks must pass:
   - `swift test`
   - `swift run forge verify-solutions --constraints-only`
6. If either post-append check fails, the target file is restored automatically.

### 6.5 Targeting Rules

- Standard target files:
  - `Sources/forge/Curriculum/core1_challenges.json`
  - `Sources/forge/Curriculum/core2_challenges.json`
  - `Sources/forge/Curriculum/core3_challenges.json`
  - `Sources/forge/Curriculum/mantle_challenges.json`
  - `Sources/forge/Curriculum/crust_challenges.json`
- Bridge target:
  - `Sources/forge/Curriculum/bridge_challenges.json`
  - Requires `--bridge-section core-to-mantle` or `--bridge-section mantle-to-crust`

### 6.6 Operational Notes

- Keep this flow on a dedicated branch (for example, `ai-integration`) until promoted content is validated.
- Prefer one promoted challenge per commit for easier review/revert.
- Run `scripts/check.sh` before opening a PR.
